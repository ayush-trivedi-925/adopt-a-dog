{"version":3,"file":"maptiler-sdk.mjs","sources":["../src/language.ts","../src/defaults.ts","../src/config.ts","../src/caching.ts","../src/tools.ts","../src/MLAdapters/Marker.ts","../src/MLAdapters/Popup.ts","../src/MLAdapters/Style.ts","../src/MLAdapters/CanvasSource.ts","../src/MLAdapters/GeoJSONSource.ts","../src/MLAdapters/ImageSource.ts","../src/MLAdapters/RasterTileSource.ts","../src/MLAdapters/RasterDEMTileSource.ts","../src/MLAdapters/VectorTileSource.ts","../src/MLAdapters/VideoSource.ts","../src/MLAdapters/NavigationControl.ts","../src/MLAdapters/GeolocateControl.ts","../src/MLAdapters/AttributionControl.ts","../src/MLAdapters/LogoControl.ts","../src/MLAdapters/ScaleControl.ts","../src/MLAdapters/FullscreenControl.ts","../src/MLAdapters/TerrainControl.ts","../src/MLAdapters/BoxZoomHandler.ts","../src/MLAdapters/ScrollZoomHandler.ts","../src/MLAdapters/CooperativeGesturesHandler.ts","../src/MLAdapters/KeyboardHandler.ts","../src/MLAdapters/TwoFingersTouchPitchHandler.ts","../src/MLAdapters/MapWheelEvent.ts","../src/MLAdapters/MapTouchEvent.ts","../src/MLAdapters/MapMouseEvent.ts","../src/MaptilerLogoControl.ts","../src/mapstyle.ts","../src/MaptilerTerrainControl.ts","../src/MaptilerNavigationControl.ts","../src/MaptilerGeolocateControl.ts","../src/Minimap.ts","../src/Map.ts","../src/converters/xml.ts","../src/colorramp.ts","../src/helpers/screenshot.ts","../src/helpers/stylehelper.ts","../src/helpers/vectorlayerhelpers.ts","../src/helpers/index.ts","../src/index.ts"],"sourcesContent":["import { Language as LanguageFromClient, getLanguageInfoFromCode, type LanguageInfo } from \"@maptiler/client\";\n\n// Adding some language entries that are specific to the SDK\nconst Language = {\n  /**\n   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR: {\n    code: null,\n    flag: \"visitor\",\n    name: \"Visitor\",\n    latin: true,\n    isMode: true,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Language mode to display labels in both the local language and English, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR_ENGLISH: {\n    code: null,\n    flag: \"visitor_en\",\n    name: \"Visitor English\",\n    latin: true,\n    isMode: true,\n    geocoding: false,\n  } as LanguageInfo,\n\n  /**\n   * Language mode to display labels in a language enforced in the style.\n   */\n  STYLE: { code: null, flag: \"style\", name: \"Style\", latin: false, isMode: true, geocoding: false } as LanguageInfo,\n\n  /**\n   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.\n   */\n  STYLE_LOCK: {\n    code: null,\n    flag: \"style_lock\",\n    name: \"Style Lock\",\n    latin: false,\n    isMode: true,\n    geocoding: false,\n  } as LanguageInfo,\n\n  ...LanguageFromClient,\n} as const;\n\n/**\n * Get the browser language\n */\nexport function getBrowserLanguage(): LanguageInfo {\n  if (typeof navigator === \"undefined\") {\n    const code = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0];\n\n    const langInfo = getLanguageInfoFromCode(code);\n\n    if (langInfo) return langInfo;\n    return Language.ENGLISH;\n  }\n\n  const canditatelangs = Array.from(new Set(navigator.languages.map((l) => l.split(\"-\")[0])))\n    .map((code) => getLanguageInfoFromCode(code))\n    .filter((li) => li);\n\n  return canditatelangs[0] ?? Language.LOCAL;\n}\n\nexport { Language, type LanguageInfo };\n","import { Language } from \"./language\";\n\n/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: Language.STYLE,\n  secondaryLanguage: Language.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","import EventEmitter from \"events\";\nimport type { LanguageInfo } from \"./language\";\nimport { config as clientConfig, type FetchFunction } from \"@maptiler/client\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport type { Unit } from \"./unit\";\nimport { defaults } from \"./defaults\";\n\nexport const MAPTILER_SESSION_ID = uuidv4();\n\n/**\n * Configuration class for the SDK\n */\nclass SdkConfig extends EventEmitter {\n  /**\n   * The primary language. By default, the language of the web browser is used.\n   */\n  primaryLanguage: LanguageInfo = defaults.primaryLanguage;\n\n  /**\n   * The secondary language, to overwrite the default language defined in the map style.\n   * This settings is highly dependant on the style compatibility and may not work in most cases.\n   */\n  secondaryLanguage?: LanguageInfo;\n\n  /**\n   * Setting on whether of not the SDK runs with a session logic.\n   * A \"session\" is started at the initialization of the SDK and finished when the browser\n   * page is being refreshed.\n   * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n   * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n   */\n  session = true;\n\n  /**\n   * Enables client-side caching of requests for tiles and fonts.\n   * The cached requests persist multiple browser sessions and will be reused when possible.\n   * Works only for requests to the MapTiler Cloud API when sessions are enabled.\n   */\n  caching = true;\n\n  /**\n   * Unit to be used\n   */\n  private _unit: Unit = \"metric\";\n\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"\";\n\n  /**\n   * Set the unit system\n   */\n  set unit(u: Unit) {\n    this._unit = u;\n    this.emit(\"unit\", u);\n  }\n\n  /**\n   * Get the unit system\n   */\n  get unit(): Unit {\n    return this._unit;\n  }\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n    clientConfig.apiKey = k;\n    this.emit(\"apiKey\", k);\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    clientConfig.fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return clientConfig.fetch;\n  }\n}\n\nconst config = new SdkConfig();\n\nexport { config, SdkConfig };\n","import type { GetResourceResponse, RequestParameters, ResourceType } from \"maplibre-gl\";\n\nimport { config } from \"./config\";\n\nimport maplibregl from \"maplibre-gl\";\n\nimport { defaults } from \"./defaults\";\n\nconst { addProtocol } = maplibregl;\n\nconst LOCAL_CACHE_PROTOCOL_SOURCE = \"localcache_source\";\nconst LOCAL_CACHE_PROTOCOL_DATA = \"localcache\";\nconst LOCAL_CACHE_NAME = \"maptiler_sdk\";\n\nconst CACHE_LIMIT_ITEMS = 1000;\nconst CACHE_LIMIT_CHECK_INTERVAL = 100;\nexport const CACHE_API_AVAILABLE = typeof caches !== \"undefined\";\n\nexport function localCacheTransformRequest(reqUrl: URL, resourceType?: ResourceType): string {\n  if (CACHE_API_AVAILABLE && config.caching && config.session && reqUrl.host === defaults.maptilerApiHost) {\n    if (resourceType === \"Source\" && reqUrl.href.includes(\"tiles.json\")) {\n      return reqUrl.href.replace(\"https://\", `${LOCAL_CACHE_PROTOCOL_SOURCE}://`);\n    }\n\n    if (resourceType === \"Tile\" || resourceType === \"Glyphs\") {\n      return reqUrl.href.replace(\"https://\", `${LOCAL_CACHE_PROTOCOL_DATA}://`);\n    }\n  }\n  return reqUrl.href;\n}\n\nlet cacheInstance: Cache;\n\nasync function getCache() {\n  if (!cacheInstance) {\n    cacheInstance = await caches.open(LOCAL_CACHE_NAME);\n  }\n  return cacheInstance;\n}\n\nlet cachePutCounter = 0;\nasync function limitCache() {\n  const cache = await getCache();\n  const keys = await cache.keys();\n  const toPurge = keys.slice(0, Math.max(keys.length - CACHE_LIMIT_ITEMS, 0));\n  for (const key of toPurge) {\n    cache.delete(key);\n  }\n}\n\nexport function registerLocalCacheProtocol() {\n  addProtocol(\n    LOCAL_CACHE_PROTOCOL_SOURCE,\n    async (\n      params: RequestParameters,\n      abortController: AbortController,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<GetResourceResponse<any>> => {\n      if (!params.url) throw new Error(\"\");\n\n      params.url = params.url.replace(`${LOCAL_CACHE_PROTOCOL_SOURCE}://`, \"https://\");\n\n      const requestInit: RequestInit = params;\n      requestInit.signal = abortController.signal;\n      const response = await fetch(params.url, requestInit);\n      const json = await response.json();\n\n      if (json.tiles && json.tiles.length > 0) {\n        // move `Last-Modified` to query so it propagates to tile URLs\n        json.tiles[0] += `&last-modified=${response.headers.get(\"Last-Modified\")}`;\n      }\n\n      return {\n        data: json,\n        cacheControl: response.headers.get(\"Cache-Control\"),\n        expires: response.headers.get(\"Expires\"),\n      };\n    },\n  );\n  addProtocol(\n    LOCAL_CACHE_PROTOCOL_DATA,\n    async (params: RequestParameters, abortController: AbortController): Promise<GetResourceResponse<any>> => {\n      if (!params.url) throw new Error(\"\");\n\n      params.url = params.url.replace(`${LOCAL_CACHE_PROTOCOL_DATA}://`, \"https://\");\n\n      const url = new URL(params.url);\n\n      const cacheableUrl = new URL(url);\n      cacheableUrl.searchParams.delete(\"mtsid\");\n      cacheableUrl.searchParams.delete(\"key\");\n      const cacheKey = cacheableUrl.toString();\n\n      const fetchableUrl = new URL(url);\n      fetchableUrl.searchParams.delete(\"last-modified\");\n      const fetchUrl = fetchableUrl.toString();\n\n      const respond = async (response: Response): Promise<GetResourceResponse<any>> => {\n        return {\n          data: await response.arrayBuffer(),\n          cacheControl: response.headers.get(\"Cache-Control\"),\n          expires: response.headers.get(\"Expires\"),\n        };\n      };\n\n      const cache = await getCache();\n      const cacheMatch = await cache.match(cacheKey);\n\n      if (cacheMatch) {\n        return respond(cacheMatch);\n      }\n\n      const requestInit: RequestInit = params;\n      requestInit.signal = abortController.signal;\n      const response = await fetch(fetchUrl, requestInit);\n      if (response.status >= 200 && response.status < 300) {\n        cache.put(cacheKey, response.clone()).catch(() => {\n          // \"DOMException: Cache.put() was aborted\"\n          // can happen here because the response is not done streaming yet\n        });\n        if (++cachePutCounter > CACHE_LIMIT_CHECK_INTERVAL) {\n          limitCache();\n          cachePutCounter = 0;\n        }\n      }\n      return respond(response);\n    },\n  );\n}\n","import maplibregl from \"maplibre-gl\";\nimport type { RequestParameters, ResourceType, RequestTransformFunction } from \"maplibre-gl\";\nimport { defaults } from \"./defaults\";\nimport { config } from \"./config\";\nimport { MAPTILER_SESSION_ID } from \"./config\";\nimport { localCacheTransformRequest } from \"./caching\";\n\nexport function enableRTL() {\n  // Prevent this from running server side\n  if (typeof window === \"undefined\") return;\n\n  const status = maplibregl.getRTLTextPluginStatus();\n\n  if (status === \"unavailable\" || status === \"requested\") {\n    try {\n      maplibregl.setRTLTextPlugin(defaults.rtlPluginURL, true);\n    } catch (e) {\n      // nothing\n    }\n  }\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/util.ts#L223\nexport function bindAll(fns: Array<string>, context: any): void {\n  for (const fn of fns) {\n    if (typeof context[fn] !== \"function\") continue;\n    context[fn] = context[fn].bind(context);\n  }\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/dom.ts#L22\nexport function DOMcreate<K extends keyof HTMLElementTagNameMap>(\n  tagName: K,\n  className?: string,\n  container?: HTMLElement,\n): HTMLElementTagNameMap[K] {\n  const el = window.document.createElement(tagName);\n  if (className !== undefined) el.className = className;\n  if (container) container.appendChild(el);\n  return el;\n}\n\n// This comes from:\n// https://github.com/maplibre/maplibre-gl-js/blob/v2.4.0/src/util/dom.ts#L111\nexport function DOMremove(node: HTMLElement) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\n/**\n * This function is meant to be used as transformRequest by any Map instance created.\n * It adds the session ID as well as the MapTiler Cloud key from the config to all the requests\n * performed on MapTiler Cloud servers.\n */\nexport function maptilerCloudTransformRequest(url: string, resourceType?: ResourceType): RequestParameters {\n  let reqUrl = null;\n\n  try {\n    // The URL is expected to be absolute.\n    // Yet, if it's local we just return it without assuming a 'base' url (in the URL constructor)\n    // and we let the URL be locally resolved with a potential base path.\n    reqUrl = new URL(url);\n  } catch (e) {\n    return {\n      url,\n    };\n  }\n\n  if (reqUrl.host === defaults.maptilerApiHost) {\n    if (!reqUrl.searchParams.has(\"key\")) {\n      reqUrl.searchParams.append(\"key\", config.apiKey);\n    }\n\n    if (config.session) {\n      reqUrl.searchParams.append(\"mtsid\", MAPTILER_SESSION_ID);\n    }\n  }\n\n  return {\n    url: localCacheTransformRequest(reqUrl, resourceType),\n  };\n}\n\n/**\n * This combines a user-defined tranformRequest function (optionnal)\n * with the MapTiler Cloud-specific one: maptilerCloudTransformRequest\n */\nexport function combineTransformRequest(userDefinedRTF?: RequestTransformFunction | null): RequestTransformFunction {\n  return (url: string, resourceType?: ResourceType): RequestParameters => {\n    if (userDefinedRTF !== undefined && userDefinedRTF !== null) {\n      const rp = userDefinedRTF(url, resourceType);\n      const rp2 = maptilerCloudTransformRequest(rp?.url ?? \"\", resourceType);\n\n      return {\n        ...rp,\n        ...rp2,\n      };\n    }\n\n    return maptilerCloudTransformRequest(url, resourceType);\n  };\n}\n\n/**\n * Generate a random string. Handy to create random IDs\n */\nexport function generateRandomString(): string {\n  return Math.random().toString(36).substring(2);\n}\n\n/**\n * Check if a given string is in a uuid format\n */\nexport function isUUID(s: string): boolean {\n  // Regular expression to check if string is a valid UUID\n  const regexExp = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi;\n  return regexExp.test(s);\n}\n\n/**\n * Attempt a JSON parse of a string but does not throw if the string is not valid JSON, returns `null` instead.\n */\nexport function jsonParseNoThrow<T>(doc: string): T | null {\n  try {\n    return JSON.parse(doc);\n  } catch (e) {\n    // pass\n  }\n\n  return null;\n}\n\n/**\n * Simple function to check if an object is a GeoJSON\n */\nexport function isValidGeoJSON<T>(obj: T & { type: string }): boolean {\n  if (typeof obj !== \"object\" || Array.isArray(obj) || obj === null) return false;\n  if (!(\"type\" in obj)) return false;\n\n  const validTypes = [\n    \"Feature\",\n    \"FeatureCollection\",\n    \"Point\",\n    \"MultiPoint\",\n    \"LineString\",\n    \"MultiLineString\",\n    \"Polygon\",\n    \"MultiPolygon\",\n    \"GeometryCollection\",\n  ];\n\n  if (validTypes.includes(obj.type)) return true;\n  return false;\n}\n\n/**\n * This function tests if WebGL2 is supported. Since it can be for a different reasons that WebGL2 is\n * not supported but we do not have an action to take based on the reason, this function return null\n * if there is no error (WebGL is supported), or returns a string with the error message if WebGL2 is\n * not supported.\n */\nexport function getWebGLSupportError(): string | null {\n  const gl = document.createElement(\"canvas\").getContext(\"webgl2\");\n  if (!gl) {\n    if (typeof WebGL2RenderingContext !== \"undefined\") {\n      return \"Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed.\";\n    }\n    return \"Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.\";\n  }\n  return null;\n}\n\n/**\n * Display an error message in the Map div if WebGL2 is not supported\n */\nexport function displayNoWebGlWarning(container: HTMLElement | string) {\n  const webglError = getWebGLSupportError();\n\n  if (!webglError) return;\n\n  let actualContainer: HTMLElement | null = null;\n\n  if (typeof container === \"string\") {\n    actualContainer = document.getElementById(container);\n  } else if (container instanceof HTMLElement) {\n    actualContainer = container;\n  }\n\n  if (!actualContainer) {\n    throw new Error(\"The Map container must be provided.\");\n  }\n\n  const errorMessageDiv = document.createElement(\"div\");\n  errorMessageDiv.innerHTML = webglError;\n  errorMessageDiv.classList.add(\"no-webgl-support-div\");\n  actualContainer.appendChild(errorMessageDiv);\n  throw new Error(webglError);\n}\n","/**\n * This is an extension of MapLibre Marker to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class Marker extends maplibregl.Marker {\n  addTo(map: SDKMap | MapMLGL): this {\n    return super.addTo(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre Popup to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class Popup extends maplibregl.Popup {\n  addTo(map: SDKMap | MapMLGL): this {\n    return super.addTo(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre Style to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL, StyleOptions } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class Style extends maplibregl.Style {\n  constructor(map: SDKMap, options: StyleOptions = {}) {\n    super(map as MapMLGL, options);\n  }\n}\n","/**\n * This is an extension of MapLibre CanvasSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class CanvasSource extends maplibregl.CanvasSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre GeoJSONSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class GeoJSONSource extends maplibregl.GeoJSONSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre ImageSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class ImageSource extends maplibregl.ImageSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre RasterTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class RasterTileSource extends maplibregl.RasterTileSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre RasterDEMTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class RasterDEMTileSource extends maplibregl.RasterDEMTileSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre VectorTileSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class VectorTileSource extends maplibregl.VectorTileSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre VideoSource to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class VideoSource extends maplibregl.VideoSource {\n  onAdd(map: SDKMap | MapMLGL) {\n    super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre NavigationControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class NavigationControl extends maplibregl.NavigationControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre GeolocateControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class GeolocateControl extends maplibregl.GeolocateControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre AttributionControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class AttributionControl extends maplibregl.AttributionControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre LogoControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class LogoControl extends maplibregl.LogoControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre ScaleControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class ScaleControl extends maplibregl.ScaleControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre FullscreenControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class FullscreenControl extends maplibregl.FullscreenControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre TerrainControl to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class TerrainControl extends maplibregl.TerrainControl {\n  onAdd(map: SDKMap | MapMLGL) {\n    return super.onAdd(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class BoxZoomHandler extends maplibregl.BoxZoomHandler {\n  constructor(\n    map: SDKMap | MapMLGL,\n    options: {\n      clickTolerance: number;\n    },\n  ) {\n    super(map as MapMLGL, options);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class ScrollZoomHandler extends maplibregl.ScrollZoomHandler {\n  constructor(map: SDKMap | MapMLGL, triggerRenderFrame: () => void) {\n    super(map as MapMLGL, triggerRenderFrame);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { GestureOptions, Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class CooperativeGesturesHandler extends maplibregl.CooperativeGesturesHandler {\n  constructor(map: SDKMap | MapMLGL, options: GestureOptions) {\n    super(map as MapMLGL, options);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class KeyboardHandler extends maplibregl.KeyboardHandler {\n  constructor(map: SDKMap | MapMLGL) {\n    super(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class TwoFingersTouchPitchHandler extends maplibregl.TwoFingersTouchPitchHandler {\n  constructor(map: SDKMap | MapMLGL) {\n    super(map as MapMLGL);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class MapWheelEvent extends maplibregl.MapWheelEvent {\n  constructor(type: string, map: SDKMap | MapMLGL, originalEvent: WheelEvent) {\n    super(type, map as MapMLGL, originalEvent);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class MapTouchEvent extends maplibregl.MapTouchEvent {\n  constructor(type: string, map: SDKMap | MapMLGL, originalEvent: TouchEvent) {\n    super(type, map as MapMLGL, originalEvent);\n  }\n}\n","/**\n * This is an extension of MapLibre BoxZoomHandler to make it fully type compatible with the SDK\n */\n\nimport maplibregl from \"maplibre-gl\";\nimport type { Map as MapMLGL } from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\n\nexport class MapMouseEvent extends maplibregl.MapMouseEvent {\n  constructor(type: string, map: SDKMap | MapMLGL, originalEvent: MouseEvent, data: any = {}) {\n    super(type, map as MapMLGL, originalEvent, data);\n  }\n}\n","import type { LogoControlOptions as LogoControlOptionsML } from \"maplibre-gl\";\nimport { defaults } from \"./defaults\";\nimport { LogoControl } from \"./MLAdapters/LogoControl\";\nimport type { Map as SDKMap } from \"./Map\";\n\ntype LogoControlOptions = LogoControlOptionsML & {\n  logoURL?: string;\n  linkURL?: string;\n};\n\n/**\n * This LogoControl extends the MapLibre LogoControl but instead can use any image URL and\n * any link URL. By default this is using MapTiler logo and URL.\n */\nexport class MaptilerLogoControl extends LogoControl {\n  declare _compact: boolean;\n  private logoURL = \"\";\n  private linkURL = \"\";\n\n  constructor(options: LogoControlOptions = {}) {\n    super(options);\n\n    this.logoURL = options.logoURL ?? defaults.maptilerLogoURL;\n    this.linkURL = options.linkURL ?? defaults.maptilerURL;\n  }\n\n  onAdd(map: SDKMap): HTMLElement {\n    this._map = map;\n    this._compact = this.options.compact ?? false;\n    this._container = window.document.createElement(\"div\");\n    this._container.className = \"maplibregl-ctrl\";\n    const anchor = window.document.createElement(\"a\");\n    anchor.style.backgroundRepeat = \"no-repeat\";\n    anchor.style.cursor = \"pointer\";\n    anchor.style.display = \"block\";\n    anchor.style.height = \"23px\";\n    anchor.style.margin = \"0 0 -4px -4px\";\n    anchor.style.overflow = \"hidden\";\n    anchor.style.width = \"88px\";\n    anchor.style.backgroundImage = `url(${this.logoURL})`;\n    anchor.style.backgroundSize = \"100px 30px\";\n    anchor.style.width = \"100px\";\n    anchor.style.height = \"30px\";\n\n    anchor.target = \"_blank\";\n    anchor.rel = \"noopener\";\n    anchor.href = this.linkURL;\n    anchor.setAttribute(\"aria-label\", \"MapTiler logo\");\n    anchor.setAttribute(\"rel\", \"noopener\");\n    this._container.appendChild(anchor);\n    this._container.style.display = \"block\";\n\n    this._map.on(\"resize\", this._updateCompact);\n    this._updateCompact();\n\n    return this._container;\n  }\n}\n","import { MapStyle, ReferenceMapStyle, MapStyleVariant, mapStylePresetList, expandMapStyle } from \"@maptiler/client\";\n\nexport function styleToStyle(\n  style: string | ReferenceMapStyle | MapStyleVariant | maplibregl.StyleSpecification | null | undefined,\n): string | maplibregl.StyleSpecification {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID as keyof typeof MapStyle]\n      .getDefaultVariant()\n      .getExpandedStyleURL();\n  }\n\n  // If the provided style is a shorthand (eg. \"streets-v2\") or a full style URL\n  if (typeof style === \"string\" || style instanceof String) {\n    if (!style.startsWith(\"http\") && style.toLowerCase().includes(\".json\")) {\n      // If a style does not start by http but still contains the extension \".json\"\n      // we assume it's a relative path to a style json file\n      return style as string;\n    }\n\n    return expandMapStyle(style);\n  }\n\n  if (style instanceof MapStyleVariant) {\n    return style.getExpandedStyleURL();\n  }\n\n  if (style instanceof ReferenceMapStyle) {\n    return (style.getDefaultVariant() as MapStyleVariant).getExpandedStyleURL();\n  }\n\n  return style as maplibregl.StyleSpecification;\n}\n","import { bindAll, DOMcreate, DOMremove } from \"./tools\";\n\nimport type { Map as SDKMap } from \"./Map\";\nimport type { IControl } from \"maplibre-gl\";\n\n/**\n * A `MaptilerTerrainControl` control adds a button to turn terrain on and off\n * by triggering the terrain logic that is already deployed in the Map object.\n */\nexport class MaptilerTerrainControl implements IControl {\n  _map!: SDKMap;\n  _container!: HTMLElement;\n  _terrainButton!: HTMLButtonElement;\n\n  constructor() {\n    bindAll([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n\n  onAdd(map: SDKMap): HTMLElement {\n    this._map = map;\n    this._container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    this._terrainButton = DOMcreate(\"button\", \"maplibregl-ctrl-terrain\", this._container);\n    DOMcreate(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\"aria-hidden\", \"true\");\n    this._terrainButton.type = \"button\";\n    this._terrainButton.addEventListener(\"click\", this._toggleTerrain);\n\n    this._updateTerrainIcon();\n    this._map.on(\"terrain\", this._updateTerrainIcon);\n    return this._container;\n  }\n\n  onRemove(): void {\n    DOMremove(this._container);\n    this._map.off(\"terrain\", this._updateTerrainIcon);\n    // @ts-expect-error: map will only be undefined on remove\n    this._map = undefined;\n  }\n\n  _toggleTerrain(): void {\n    if (this._map.hasTerrain()) {\n      this._map.disableTerrain();\n    } else {\n      this._map.enableTerrain();\n    }\n\n    this._updateTerrainIcon();\n  }\n\n  _updateTerrainIcon(): void {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\");\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\");\n    // if (this._map.terrain) {\n    if (this._map.hasTerrain()) {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\");\n      this._terrainButton.title = this._map._getUIString(\"TerrainControl.Disable\");\n    } else {\n      this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\");\n      this._terrainButton.title = this._map._getUIString(\"TerrainControl.Enable\");\n    }\n  }\n}\n","import type { NavigationControlOptions } from \"maplibre-gl\";\nimport { NavigationControl } from \"./MLAdapters/NavigationControl\";\n\ntype HTMLButtonElementPlus = HTMLButtonElement & {\n  clickFunction: (e?: Event) => unknown;\n};\n\nexport class MaptilerNavigationControl extends NavigationControl {\n  constructor(options: NavigationControlOptions = {}) {\n    super({\n      showCompass: options.showCompass ?? true,\n      showZoom: options.showZoom ?? true,\n      visualizePitch: options.visualizePitch ?? true,\n    });\n\n    // Removing the default click event\n    if (this._compass) {\n      this._compass.removeEventListener(\"click\", (this._compass as HTMLButtonElementPlus).clickFunction);\n\n      // Adding custom click event\n      this._compass.addEventListener(\"click\", (e) => {\n        {\n          const currentPitch = this._map.getPitch();\n          if (currentPitch === 0) {\n            this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) });\n          } else {\n            if (this.options.visualizePitch) {\n              this._map.resetNorthPitch({}, { originalEvent: e });\n            } else {\n              this._map.resetNorth({}, { originalEvent: e });\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(className: string, fn: (e?: Event) => unknown): HTMLButtonElementPlus {\n    const button = super._createButton(className, fn) as HTMLButtonElementPlus;\n    button.clickFunction = fn;\n    return button;\n  }\n\n  /**\n   * Overloading: Limit how flat the compass icon can get\n   */\n  _rotateCompassArrow = () => {\n    const rotate = this.options.visualizePitch\n      ? `scale(${Math.min(\n          1.5,\n          1 / Math.cos(this._map.transform.pitch * (Math.PI / 180)) ** 0.5,\n        )}) rotateX(${Math.min(70, this._map.transform.pitch)}deg) rotateZ(${\n          this._map.transform.angle * (180 / Math.PI)\n        }deg)`\n      : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;\n\n    this._compassIcon.style.transform = rotate;\n  };\n}\n","import type { LngLatLike, MapLibreEvent } from \"maplibre-gl\";\nimport maplibregl from \"maplibre-gl\";\nimport { GeolocateControl } from \"./MLAdapters/GeolocateControl\";\nimport { DOMcreate } from \"./tools\";\n\nconst Marker = maplibregl.Marker;\nconst LngLat = maplibregl.LngLat;\nconst LngLatBounds = maplibregl.LngLatBounds;\n\ntype MoveEndEvent = MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined> & { geolocateSource?: boolean };\n\n/**\n * The MaptilerGeolocateControl is an extension of the original GeolocateControl\n * with a few changes. In this version, the active mode persists as long as the\n * location is still centered. This means it's robust to rotation, pitch and zoom.\n *\n */\nexport class MaptilerGeolocateControl extends GeolocateControl {\n  private lastUpdatedCenter = new LngLat(0, 0);\n\n  /**\n   * Update the camera location to center on the current position\n   *\n   * @param {Position} position the Geolocation API Position\n   * @private\n   */\n  _updateCamera = (position: GeolocationPosition) => {\n    const center = new LngLat(position.coords.longitude, position.coords.latitude);\n    const radius = position.coords.accuracy;\n    const bearing = this._map.getBearing();\n    const options = {\n      bearing,\n      ...this.options.fitBoundsOptions,\n      linear: true,\n    };\n\n    const currentMapZoom = this._map.getZoom();\n\n    if (currentMapZoom > (this.options?.fitBoundsOptions?.maxZoom ?? 30)) {\n      options.zoom = currentMapZoom;\n    }\n\n    this._map.fitBounds(LngLatBounds.fromLngLat(center, radius), options, {\n      geolocateSource: true, // tag this camera change so it won't cause the control to change to background state\n    });\n\n    let hasFittingBeenDisrupted = false;\n\n    const flagFittingDisruption = () => {\n      hasFittingBeenDisrupted = true;\n    };\n\n    this._map.once(\"click\", flagFittingDisruption);\n    this._map.once(\"dblclick\", flagFittingDisruption);\n    this._map.once(\"dragstart\", flagFittingDisruption);\n    this._map.once(\"mousedown\", flagFittingDisruption);\n    this._map.once(\"touchstart\", flagFittingDisruption);\n    this._map.once(\"wheel\", flagFittingDisruption);\n\n    this._map.once(\"moveend\", () => {\n      // Removing the events if not used\n      this._map.off(\"click\", flagFittingDisruption);\n      this._map.off(\"dblclick\", flagFittingDisruption);\n      this._map.off(\"dragstart\", flagFittingDisruption);\n      this._map.off(\"mousedown\", flagFittingDisruption);\n      this._map.off(\"touchstart\", flagFittingDisruption);\n      this._map.off(\"wheel\", flagFittingDisruption);\n\n      if (hasFittingBeenDisrupted) {\n        return;\n      }\n\n      this.lastUpdatedCenter = this._map.getCenter();\n    });\n  };\n\n  _finishSetupUI = (supported: boolean) => {\n    // this method is called asynchronously during onAdd\n    if (!this._map) {\n      // control has since been removed\n      return;\n    }\n\n    if (supported === false) {\n      // warnOnce('Geolocation support is not available so the GeolocateControl will be disabled.');\n      const title = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n      this._geolocateButton.disabled = true;\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    } else {\n      const title = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n      this._geolocateButton.disabled = false;\n      this._geolocateButton.title = title;\n      this._geolocateButton.setAttribute(\"aria-label\", title);\n    }\n\n    if (this.options.trackUserLocation) {\n      this._geolocateButton.setAttribute(\"aria-pressed\", \"false\");\n      this._watchState = \"OFF\";\n    }\n\n    // when showUserLocation is enabled, keep the Geolocate button disabled until the device location marker is setup on the map\n    if (this.options.showUserLocation) {\n      this._dotElement = DOMcreate(\"div\", \"maplibregl-user-location-dot\");\n      this._userLocationDotMarker = new Marker({ element: this._dotElement });\n\n      this._circleElement = DOMcreate(\"div\", \"maplibregl-user-location-accuracy-circle\");\n      this._accuracyCircleMarker = new Marker({\n        element: this._circleElement,\n        pitchAlignment: \"map\",\n      });\n\n      if (this.options.trackUserLocation) this._watchState = \"OFF\";\n\n      this._map.on(\"move\", this._onZoom);\n    }\n\n    this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this));\n\n    this._setup = true;\n\n    // when the camera is changed (and it's not as a result of the Geolocation Control) change\n    // the watch mode to background watch, so that the marker is updated but not the camera.\n    // Addition: Yet the status change does not occur if the ditance it has moved to is less than\n    // one meter from the last auto-updated position. This is to guarrantee that if the move\n    // is a zoom, rotation or pitch (where the center stays the same) then we can keep the ACTIVE_LOCK\n    // mode ON.\n    if (this.options.trackUserLocation) {\n      this._map.on(\"moveend\", (event: MoveEndEvent) => {\n        const fromResize = event.originalEvent && event.originalEvent.type === \"resize\";\n        const movingDistance = this.lastUpdatedCenter.distanceTo(this._map.getCenter());\n\n        if (!event.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !fromResize && movingDistance > 1) {\n          this._watchState = \"BACKGROUND\";\n          this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\");\n          this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\");\n\n          this.fire(new Event(\"trackuserlocationend\"));\n        }\n      });\n    }\n  };\n\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\") {\n      return;\n    }\n\n    const lastKnownLocation: LngLatLike = [\n      this._lastKnownPosition.coords.longitude,\n      this._lastKnownPosition.coords.latitude,\n    ];\n\n    const projectedLocation = this._map.project(lastKnownLocation);\n    const a = this._map.unproject([projectedLocation.x, projectedLocation.y]);\n    const b = this._map.unproject([projectedLocation.x + 20, projectedLocation.y]);\n    const metersPerPixel = a.distanceTo(b) / 20;\n\n    const circleDiameter = Math.ceil((2.0 * this._accuracy) / metersPerPixel);\n    this._circleElement.style.width = `${circleDiameter}px`;\n    this._circleElement.style.height = `${circleDiameter}px`;\n  }\n\n  _onZoom = () => {\n    if (this.options.showUserLocation && this.options.showAccuracyCircle) {\n      this._updateCircleRadius();\n    }\n  };\n}\n","/**\n * This is an extension adds support for adding a minimap to one of the map's control containers.\n */\n\nimport { Map as SDKMap } from \"./Map\";\nimport { DOMcreate, DOMremove } from \"./tools\";\n\nimport type {\n  ControlPosition,\n  CustomLayerInterface,\n  FillLayerSpecification,\n  FilterSpecification,\n  GeoJSONSource,\n  IControl,\n  LayerSpecification,\n  LineLayerSpecification,\n  SourceSpecification,\n  StyleOptions,\n  StyleSetterOptions,\n  StyleSpecification,\n  StyleSwapOptions,\n} from \"maplibre-gl\";\nimport type { MapOptions } from \"./Map\";\nimport type { MapStyleVariant, ReferenceMapStyle } from \"@maptiler/client\";\n\nexport interface ParentRect {\n  lineLayout: LineLayerSpecification[\"layout\"];\n  linePaint: LineLayerSpecification[\"paint\"];\n  fillPaint: FillLayerSpecification[\"paint\"];\n}\n\nexport interface MinimapOptionsInput {\n  /**\n   * Style of the map. Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  style?: ReferenceMapStyle | MapStyleVariant | StyleSpecification | string;\n\n  /**\n   * Set the zoom difference between the parent and the minimap\n   * If the parent is zoomed to 10 and the minimap is zoomed to 8, the zoomAdjust should be 2\n   * Default: -4\n   */\n  zoomAdjust?: number;\n\n  /** Set a zoom of the minimap and don't allow any future changes */\n  lockZoom?: number;\n\n  /** Adjust the pitch only if the user requests */\n  pitchAdjust?: boolean;\n\n  /** Set CSS properties of the container using object key-values */\n  containerStyle?: Record<string, string>;\n\n  /** Set the position of the minimap at either \"top-left\", \"top-right\", \"bottom-left\", or \"bottom-right\" */\n  position?: ControlPosition;\n\n  /** Set the parentRect fill and/or line options */\n  parentRect?: ParentRect;\n}\n\nexport interface MinimapOptions extends MapOptions {\n  zoomAdjust: number;\n  pitchAdjust: boolean;\n  containerStyle: Record<string, string>;\n  parentRect?: ParentRect;\n}\n\nexport default class Minimap implements IControl {\n  #options: MinimapOptions;\n  map!: SDKMap;\n  #parentMap!: SDKMap;\n  #container!: HTMLElement;\n  #parentRect?: GeoJSON.Feature<GeoJSON.Polygon>;\n  #differentStyle = false;\n  #desync?: () => void;\n  constructor(options: MinimapOptionsInput, mapOptions: MapOptions) {\n    // check if the style is different\n    if (options.style !== undefined) this.#differentStyle = true;\n    // set options\n    this.#options = {\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\",\n      // inherit map options\n      ...mapOptions,\n      // override any lingering control options\n      forceNoAttributionControl: true,\n      attributionControl: false,\n      navigationControl: false,\n      geolocateControl: false,\n      maptilerLogo: false,\n      minimap: false,\n      hash: false,\n      pitchAdjust: false,\n      // override map options with new user defined minimap options\n      ...options,\n      containerStyle: {\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\",\n        ...(options.containerStyle ?? {}),\n      },\n    };\n    if (options.lockZoom !== undefined) {\n      this.#options.minZoom = options.lockZoom;\n      this.#options.maxZoom = options.lockZoom;\n    }\n  }\n\n  setStyle(\n    style: null | ReferenceMapStyle | MapStyleVariant | StyleSpecification | string,\n    options?: StyleSwapOptions & StyleOptions,\n  ): void {\n    if (!this.#differentStyle) this.map.setStyle(style, options);\n    this.#setParentBounds();\n  }\n\n  addLayer(\n    layer:\n      | (LayerSpecification & {\n          source?: string | SourceSpecification;\n        })\n      | CustomLayerInterface,\n    beforeId?: string,\n  ): SDKMap {\n    if (!this.#differentStyle) this.map.addLayer(layer, beforeId);\n    this.#setParentBounds();\n    return this.map;\n  }\n\n  moveLayer(id: string, beforeId?: string): SDKMap {\n    if (!this.#differentStyle) this.map.moveLayer(id, beforeId);\n    this.#setParentBounds();\n    return this.map;\n  }\n\n  removeLayer(id: string): this {\n    if (!this.#differentStyle) this.map.removeLayer(id);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this {\n    if (!this.#differentStyle) this.map.setLayerZoomRange(layerId, minzoom, maxzoom);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setFilter(layerId: string, filter?: FilterSpecification | null, options?: StyleSetterOptions): this {\n    if (!this.#differentStyle) this.map.setFilter(layerId, filter, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setPaintProperty(\n    layerId: string,\n    name: string,\n    // maplibre controlled types\n    value: any,\n    options?: StyleSetterOptions,\n  ): this {\n    if (!this.#differentStyle) this.map.setPaintProperty(layerId, name, value, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setLayoutProperty(\n    layerId: string,\n    name: string,\n    // maplibre controlled types\n    value: any,\n    options?: StyleSetterOptions,\n  ): this {\n    if (!this.#differentStyle) this.map.setLayoutProperty(layerId, name, value, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  setGlyphs(glyphsUrl: string | null, options?: StyleSetterOptions): this {\n    if (!this.#differentStyle) this.map.setGlyphs(glyphsUrl, options);\n    this.#setParentBounds();\n    return this;\n  }\n\n  onAdd(parentMap: SDKMap): HTMLElement {\n    this.#parentMap = parentMap;\n    //prep the container\n    this.#container = DOMcreate(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\");\n    // adjust styling\n    for (const [key, value] of Object.entries(this.#options.containerStyle)) {\n      this.#container.style.setProperty(key, value);\n    }\n    this.#options.container = this.#container;\n    this.#options.zoom = parentMap.getZoom() + this.#options.zoomAdjust;\n    this.map = new SDKMap(this.#options);\n\n    // NOTE: For some reason the DOM doesn't properly update it's size in time\n    // for the minimap to convey it's size to the canvas.\n    this.map.once(\"style.load\", () => {\n      this.map.resize();\n    });\n\n    // set options\n    this.map.once(\"load\", () => {\n      this.#addParentRect(this.#options.parentRect);\n      this.#desync = this.#syncMaps();\n    });\n\n    return this.#container;\n  }\n\n  onRemove(): void {\n    this.#desync?.();\n    DOMremove(this.#container);\n  }\n\n  #addParentRect(rect?: ParentRect): void {\n    if (rect === undefined || (rect.linePaint === undefined && rect.fillPaint === undefined)) {\n      return;\n    }\n    this.#parentRect = {\n      type: \"Feature\",\n      properties: {\n        name: \"parentRect\",\n      },\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [[[], [], [], [], []]],\n      },\n    };\n\n    this.map.addSource(\"parentRect\", {\n      type: \"geojson\",\n      data: this.#parentRect,\n    });\n    if (rect.lineLayout !== undefined || rect.linePaint !== undefined) {\n      this.map.addLayer({\n        id: \"parentRectOutline\",\n        type: \"line\",\n        source: \"parentRect\",\n        layout: {\n          ...rect.lineLayout,\n        },\n        paint: {\n          \"line-color\": \"#FFF\",\n          \"line-width\": 1,\n          \"line-opacity\": 0.85,\n          ...rect.linePaint,\n        },\n      });\n    }\n    if (rect.fillPaint !== undefined) {\n      this.map.addLayer({\n        id: \"parentRectFill\",\n        type: \"fill\",\n        source: \"parentRect\",\n        layout: {},\n        paint: {\n          \"fill-color\": \"#08F\",\n          \"fill-opacity\": 0.135,\n          ...rect.fillPaint,\n        },\n      });\n    }\n\n    this.#setParentBounds();\n  }\n\n  #setParentBounds() {\n    if (this.#parentRect === undefined) return;\n\n    const { devicePixelRatio } = window;\n    const canvas = this.#parentMap.getCanvas();\n    const width = canvas.width / devicePixelRatio;\n    const height = canvas.height / devicePixelRatio;\n\n    // Get coordinates for all four corners\n    const unproject = this.#parentMap.unproject.bind(this.#parentMap);\n    const northWest = unproject([0, 0]);\n    const northEast = unproject([width, 0]);\n    const southWest = unproject([0, height]);\n    const southEast = unproject([width, height]);\n\n    this.#parentRect.geometry.coordinates = [\n      [southWest.toArray(), southEast.toArray(), northEast.toArray(), northWest.toArray(), southWest.toArray()],\n    ];\n\n    const source = this.map.getSource(\"parentRect\") as GeoJSONSource;\n    source.setData(this.#parentRect);\n  }\n\n  #syncMaps(): () => void {\n    const { pitchAdjust } = this.#options;\n    // syncing callbacks\n    const parentCallback = () => {\n      sync(\"parent\");\n    };\n    const minimapCallback = () => {\n      sync(\"minimap\");\n    };\n\n    // on off functions\n    const on = () => {\n      this.#parentMap.on(\"move\", parentCallback);\n      this.map.on(\"move\", minimapCallback);\n    };\n    const off = () => {\n      this.#parentMap.off(\"move\", parentCallback);\n      this.map.off(\"move\", minimapCallback);\n    };\n\n    // When one map moves, we turn off the movement listeners\n    // on all the maps, move it, then turn the listeners on again\n    const sync = (which: \"parent\" | \"minimap\") => {\n      // OFF\n      off();\n\n      // MOVE\n      const from = which === \"parent\" ? this.#parentMap : this.map;\n      const to = which === \"parent\" ? this.map : this.#parentMap;\n      const center = from.getCenter();\n      const zoom = from.getZoom() + this.#options.zoomAdjust * (which === \"parent\" ? 1 : -1);\n      const bearing = from.getBearing();\n      const pitch = from.getPitch();\n      to.jumpTo({\n        center,\n        zoom,\n        bearing,\n        pitch: pitchAdjust ? pitch : 0,\n      });\n      // update parent rect\n      this.#setParentBounds();\n\n      // ON\n      on();\n    };\n\n    on();\n    // return a desync function\n    return () => {\n      off();\n    };\n  }\n}\n","import maplibregl from \"maplibre-gl\";\nimport { Base64 } from \"js-base64\";\nimport type {\n  StyleSpecification,\n  MapOptions as MapOptionsML,\n  ControlPosition,\n  StyleSwapOptions,\n  StyleOptions,\n  MapDataEvent,\n  // Tile,\n  RasterDEMSourceSpecification,\n  RequestTransformFunction,\n  Source,\n  LayerSpecification,\n  SourceSpecification,\n  CustomLayerInterface,\n  FilterSpecification,\n  StyleSetterOptions,\n  ExpressionSpecification,\n  SymbolLayerSpecification,\n  AttributionControlOptions,\n} from \"maplibre-gl\";\nimport type { ReferenceMapStyle, MapStyleVariant } from \"@maptiler/client\";\nimport { config, MAPTILER_SESSION_ID, type SdkConfig } from \"./config\";\nimport { defaults } from \"./defaults\";\nimport { MaptilerLogoControl } from \"./MaptilerLogoControl\";\nimport { combineTransformRequest, displayNoWebGlWarning } from \"./tools\";\nimport { getBrowserLanguage, Language, type LanguageInfo } from \"./language\";\nimport { styleToStyle } from \"./mapstyle\";\nimport { MaptilerTerrainControl } from \"./MaptilerTerrainControl\";\nimport { MaptilerNavigationControl } from \"./MaptilerNavigationControl\";\nimport { geolocation, getLanguageInfoFromFlag, toLanguageInfo } from \"@maptiler/client\";\nimport { MaptilerGeolocateControl } from \"./MaptilerGeolocateControl\";\nimport { ScaleControl } from \"./MLAdapters/ScaleControl\";\nimport { FullscreenControl } from \"./MLAdapters/FullscreenControl\";\n\nimport Minimap from \"./Minimap\";\nimport type { MinimapOptionsInput } from \"./Minimap\";\nimport { CACHE_API_AVAILABLE, registerLocalCacheProtocol } from \"./caching\";\n\nexport type LoadWithTerrainEvent = {\n  type: \"loadWithTerrain\";\n  target: Map;\n  terrain: {\n    source: string;\n    exaggeration: number;\n  };\n};\n\nexport const GeolocationType: {\n  POINT: \"POINT\";\n  COUNTRY: \"COUNTRY\";\n} = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\",\n} as const;\n\ntype MapTerrainDataEvent = MapDataEvent & {\n  isSourceLoaded: boolean;\n  // tile: Tile;\n  sourceId: string;\n  source: RasterDEMSourceSpecification;\n};\n\n/**\n * Options to provide to the `Map` constructor\n */\nexport type MapOptions = Omit<MapOptionsML, \"style\" | \"maplibreLogo\"> & {\n  /**\n   * Style of the map. Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  style?: ReferenceMapStyle | MapStyleVariant | StyleSpecification | string;\n\n  /**\n   * Define the language of the map. This can be done directly with a language ISO code (eg. \"en\")\n   * or with a built-in shorthand (eg. Language.ENGLISH).\n   * Note that this is equivalent to setting the `config.primaryLanguage` and will overwrite it.\n   */\n  language?: LanguageInfo;\n\n  /**\n   * Define the MapTiler Cloud API key to be used. This is strictly equivalent to setting\n   * `config.apiKey` and will overwrite it.\n   */\n  apiKey?: string;\n\n  /**\n   * Shows or hides the MapTiler logo in the bottom left corner.\n   *\n   * For paid plans:\n   * - `true` shows MapTiler logo\n   * - `false` hodes MapTiler logo\n   * - default: `false` (hide)\n   *\n   * For free plans: MapTiler logo always shows, regardless of the value.\n   */\n  maptilerLogo?: boolean;\n\n  /**\n   * Attribution text to show in an {@link AttributionControl}.\n   */\n  customAttribution?: string | Array<string>;\n\n  /**\n   * Enables 3D terrain if `true`. (default: `false`)\n   */\n  terrain?: boolean;\n\n  /**\n   * Exaggeration factor of the terrain. (default: `1`, no exaggeration)\n   */\n  terrainExaggeration?: number;\n\n  /**\n   * Show the navigation control. (default: `true`, will hide if `false`)\n   */\n  navigationControl?: boolean | ControlPosition;\n\n  /**\n   * Show the terrain control. (default: `false`, will show if `true`)\n   */\n  terrainControl?: boolean | ControlPosition;\n\n  /**\n   * Show the geolocate control. (default: `true`, will hide if `false`)\n   */\n  geolocateControl?: boolean | ControlPosition;\n\n  /**\n   * Show the scale control. (default: `false`, will show if `true`)\n   */\n  scaleControl?: boolean | ControlPosition;\n\n  /**\n   * Show the full screen control. (default: `false`, will show if `true`)\n   */\n  fullscreenControl?: boolean | ControlPosition;\n\n  /**\n   * Display a minimap in a user defined corner of the map. (default: `bottom-left` corner)\n   * If set to true, the map will assume it is a minimap and forego the attribution control.\n   */\n  minimap?: boolean | ControlPosition | MinimapOptionsInput;\n\n  /**\n   * attributionControl\n   */\n  forceNoAttributionControl?: boolean;\n\n  /**\n   * Method to position the map at a given geolocation. Only if:\n   * - `hash` is `false`\n   * - `center` is not provided\n   *\n   * If the value is `true` of `\"POINT\"` (given by `GeolocationType.POINT`) then the positionning uses the MapTiler Cloud\n   * Geolocation to find the non-GPS location point.\n   * The zoom level can be provided in the `Map` constructor with the `zoom` option or will be `13` if not provided.\n   *\n   * If the value is `\"COUNTRY\"` (given by `GeolocationType.COUNTRY`) then the map is centered around the bounding box of the country.\n   * In this case, the `zoom` option will be ignored.\n   *\n   * If the value is `false`, no geolocation is performed and the map centering and zooming depends on other options or on\n   * the built-in defaults.\n   *\n   * If this option is non-false and the options `center` is also provided, then `center` prevails.\n   *\n   * Default: `false`\n   */\n  geolocate?: (typeof GeolocationType)[keyof typeof GeolocationType] | boolean;\n};\n\n/**\n * The Map class can be instanciated to display a map in a `<div>`\n */\n// biome-ignore lint/suspicious/noShadowRestrictedNames: we want to keep consitency with MapLibre\nexport class Map extends maplibregl.Map {\n  private isTerrainEnabled = false;\n  private terrainExaggeration = 1;\n  private primaryLanguage: LanguageInfo;\n  private terrainGrowing = false;\n  private terrainFlattening = false;\n  private minimap?: Minimap;\n  private forceLanguageUpdate: boolean;\n  private languageAlwaysBeenStyle: boolean;\n  private isReady = false;\n\n  constructor(options: MapOptions) {\n    displayNoWebGlWarning(options.container);\n\n    if (options.apiKey) {\n      config.apiKey = options.apiKey;\n    }\n\n    const style = styleToStyle(options.style);\n    const hashPreConstructor = location.hash;\n\n    if (!config.apiKey) {\n      console.warn(\"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\");\n    }\n\n    // default attribution control options\n    let attributionControlOptions = {\n      compact: false,\n    } as AttributionControlOptions;\n    if (options.customAttribution) {\n      attributionControlOptions.customAttribution = options.customAttribution;\n    } else if (options.attributionControl && typeof options.attributionControl === \"object\") {\n      attributionControlOptions = {\n        ...attributionControlOptions,\n        ...options.attributionControl,\n      };\n    }\n\n    // calling the map constructor with full length style\n    super({\n      ...options,\n      style,\n      maplibreLogo: false,\n      transformRequest: combineTransformRequest(options.transformRequest),\n      attributionControl: options.forceNoAttributionControl === true ? false : attributionControlOptions,\n    });\n\n    if (config.caching && !CACHE_API_AVAILABLE) {\n      console.warn(\n        \"The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache\",\n      );\n    }\n\n    if (config.caching && CACHE_API_AVAILABLE) {\n      registerLocalCacheProtocol();\n    }\n\n    this.primaryLanguage = options.language ?? config.primaryLanguage;\n    this.forceLanguageUpdate =\n      this.primaryLanguage === Language.STYLE || this.primaryLanguage === Language.STYLE_LOCK ? false : true;\n    this.languageAlwaysBeenStyle = this.primaryLanguage === Language.STYLE;\n    this.terrainExaggeration = options.terrainExaggeration ?? this.terrainExaggeration;\n\n    // Map centering and geolocation\n    this.once(\"styledata\", async () => {\n      // Not using geolocation centering if...\n\n      // the geolcoate option is not provided or is falsy\n      if (!options.geolocate) {\n        return;\n      }\n\n      // ... a center is provided in options\n      if (options.center) {\n        return;\n      }\n\n      // ... the hash option is enabled and a hash is present in the URL\n      if (options.hash && !!hashPreConstructor) {\n        return;\n      }\n\n      // If the geolocation is set to COUNTRY:\n      try {\n        if (options.geolocate === GeolocationType.COUNTRY) {\n          await this.fitToIpBounds();\n          return;\n        }\n      } catch (e) {\n        // not raising\n        console.warn((e as Error).message);\n      }\n\n      // As a fallback, we want to center the map on the visitor. First with IP geolocation...\n      let ipLocatedCameraHash: string;\n      try {\n        await this.centerOnIpPoint(options.zoom);\n        ipLocatedCameraHash = this.getCameraHash();\n      } catch (e) {\n        // not raising\n        console.warn((e as Error).message);\n      }\n\n      // A more precise localization\n\n      // This more advanced localization is commented out because the easeTo animation\n      // triggers an error if the terrain grow is enabled (due to being nable to project the center while moving)\n\n      // Then, the get a more precise location, we rely on the browser location, but only if it was already granted\n      // before (we don't want to ask wih a popup at launch time)\n      const locationResult = await navigator.permissions.query({\n        name: \"geolocation\",\n      });\n\n      if (locationResult.state === \"granted\") {\n        navigator.geolocation.getCurrentPosition(\n          // success callback\n          (data) => {\n            // If the user has already moved since the ip location, then we no longer want to move the center\n            if (ipLocatedCameraHash !== this.getCameraHash()) {\n              return;\n            }\n\n            if (this.terrain) {\n              this.easeTo({\n                center: [data.coords.longitude, data.coords.latitude],\n                zoom: options.zoom || 12,\n                duration: 2000,\n              });\n            } else {\n              this.once(\"terrain\", () => {\n                this.easeTo({\n                  center: [data.coords.longitude, data.coords.latitude],\n                  zoom: options.zoom || 12,\n                  duration: 2000,\n                });\n              });\n            }\n          },\n\n          // error callback\n          null,\n\n          // options\n          {\n            maximumAge: 24 * 3600 * 1000, // a day in millisec\n            timeout: 5000, // milliseconds\n            enableHighAccuracy: false,\n          },\n        );\n      }\n    });\n\n    // If the config includes language changing, we must update the map language\n    this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    });\n\n    // this even is in charge of reaplying the terrain elevation after the\n    // style has changed because depending on the src/tgt style,\n    // the style logic is not always able to resolve the application of terrain\n    this.on(\"styledata\", () => {\n      // the styling resolver did no manage to reaply the terrain,\n      // so let's reload it\n      if (this.getTerrain() === null && this.isTerrainEnabled) {\n        this.enableTerrain(this.terrainExaggeration);\n      }\n    });\n\n    // Update logo and attibution\n    this.once(\"load\", async () => {\n      let tileJsonContent = { logo: null };\n\n      try {\n        const possibleSources = Object.keys(this.style.sourceCaches)\n          .map((sourceName) => this.getSource(sourceName))\n          .filter(\n            (s: Source | undefined) => s && \"url\" in s && typeof s.url === \"string\" && s?.url.includes(\"tiles.json\"),\n          );\n\n        const styleUrl = new URL((possibleSources[0] as maplibregl.VectorTileSource).url);\n\n        if (!styleUrl.searchParams.has(\"key\")) {\n          styleUrl.searchParams.append(\"key\", config.apiKey);\n        }\n\n        const tileJsonRes = await fetch(styleUrl.href);\n        tileJsonContent = await tileJsonRes.json();\n      } catch (e) {\n        // No tiles.json found (should not happen on maintained styles)\n      }\n\n      // The attribution and logo must show when required\n      if (options.forceNoAttributionControl !== true) {\n        if (\"logo\" in tileJsonContent && tileJsonContent.logo) {\n          const logoURL: string = tileJsonContent.logo;\n\n          this.addControl(new MaptilerLogoControl({ logoURL }), options.logoPosition);\n        } else if (options.maptilerLogo) {\n          this.addControl(new MaptilerLogoControl(), options.logoPosition);\n        }\n      }\n\n      // the other controls at init time but be after\n      // (due to the async nature of logo control)\n\n      // By default, no scale control\n      if (options.scaleControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.scaleControl === true || options.scaleControl === undefined ? \"bottom-right\" : options.scaleControl\n        ) as ControlPosition;\n\n        const scaleControl = new ScaleControl({ unit: config.unit });\n        this.addControl(scaleControl, position);\n        config.on(\"unit\", (unit) => {\n          scaleControl.setUnit(unit);\n        });\n      }\n\n      if (options.navigationControl !== false) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.navigationControl === true || options.navigationControl === undefined\n            ? \"top-right\"\n            : options.navigationControl\n        ) as ControlPosition;\n        this.addControl(new MaptilerNavigationControl(), position);\n      }\n\n      if (options.geolocateControl !== false) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.geolocateControl === true || options.geolocateControl === undefined\n            ? \"top-right\"\n            : options.geolocateControl\n        ) as ControlPosition;\n\n        this.addControl(\n          // new maplibregl.GeolocateControl({\n          new MaptilerGeolocateControl({\n            positionOptions: {\n              enableHighAccuracy: true,\n              maximumAge: 0,\n              timeout: 6000 /* 6 sec */,\n            },\n            fitBoundsOptions: {\n              maxZoom: 15,\n            },\n            trackUserLocation: true,\n            showAccuracyCircle: true,\n            showUserLocation: true,\n          }),\n          position,\n        );\n      }\n\n      if (options.terrainControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.terrainControl === true || options.terrainControl === undefined ? \"top-right\" : options.terrainControl\n        ) as ControlPosition;\n        this.addControl(new MaptilerTerrainControl(), position);\n      }\n\n      // By default, no fullscreen control\n      if (options.fullscreenControl) {\n        // default position, if not provided, is top left corner\n        const position = (\n          options.fullscreenControl === true || options.fullscreenControl === undefined\n            ? \"top-right\"\n            : options.fullscreenControl\n        ) as ControlPosition;\n\n        this.addControl(new FullscreenControl({}), position);\n      }\n\n      this.isReady = true;\n      this.fire(\"ready\", { target: this });\n    });\n\n    // Creating a custom event: \"loadWithTerrain\"\n    // that fires only once when both:\n    // - the map has full ready (corresponds to the the \"ready\" event)\n    // - the terrain has loaded (corresponds to the \"terrain\" event with terrain beion non-null)\n    // This custom event is necessary to wait for when the map is instanciated with `terrain: true`\n    // and some animation (flyTo, easeTo) are running from the begining.\n    let loadEventTriggered = false;\n    let terrainEventTriggered = false;\n    let terrainEventData: LoadWithTerrainEvent;\n\n    this.once(\"ready\", () => {\n      loadEventTriggered = true;\n      if (terrainEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData);\n      }\n    });\n\n    this.once(\"style.load\", () => {\n      const { minimap } = options;\n      if (typeof minimap === \"object\") {\n        const {\n          zoom,\n          center,\n          style,\n          language,\n          apiKey,\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle,\n        } = options;\n        this.minimap = new Minimap(minimap, {\n          zoom,\n          center,\n          style,\n          language,\n          apiKey,\n          container: \"null\",\n          maptilerLogo,\n          antialias,\n          refreshExpiredTiles,\n          maxBounds,\n          scrollZoom,\n          minZoom,\n          maxZoom,\n          boxZoom,\n          locale,\n          fadeDuration,\n          crossSourceCollisions,\n          clickTolerance,\n          bounds,\n          fitBoundsOptions,\n          pixelRatio,\n          validateStyle,\n        });\n        this.addControl(this.minimap, minimap.position ?? \"bottom-left\");\n      } else if (minimap === true) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, \"bottom-left\");\n      } else if (minimap !== undefined && minimap !== false) {\n        this.minimap = new Minimap({}, options);\n        this.addControl(this.minimap, minimap);\n      }\n    });\n\n    const terrainCallback = (evt: LoadWithTerrainEvent) => {\n      if (!evt.terrain) return;\n      terrainEventTriggered = true;\n      terrainEventData = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: evt.terrain,\n      };\n      this.off(\"terrain\", terrainCallback);\n\n      if (loadEventTriggered) {\n        this.fire(\"loadWithTerrain\", terrainEventData as LoadWithTerrainEvent);\n      }\n    };\n\n    this.on(\"terrain\", terrainCallback);\n\n    // enable 3D terrain if provided in options\n    if (options.terrain) {\n      this.enableTerrain(options.terrainExaggeration ?? this.terrainExaggeration);\n    }\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  async onLoadAsync() {\n    return new Promise<Map>((resolve) => {\n      if (this.loaded()) {\n        return resolve(this);\n      }\n\n      this.once(\"load\", () => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  async onReadyAsync() {\n    return new Promise<Map>((resolve) => {\n      if (this.isReady) {\n        return resolve(this);\n      }\n\n      this.once(\"ready\", () => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  async onLoadWithTerrainAsync() {\n    return new Promise<Map>((resolve) => {\n      if (this.isReady && this.terrain) {\n        return resolve(this);\n      }\n\n      this.once(\"loadWithTerrain\", () => {\n        resolve(this);\n      });\n    });\n  }\n\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  override setStyle(\n    style: null | ReferenceMapStyle | MapStyleVariant | StyleSpecification | string,\n    options?: StyleSwapOptions & StyleOptions,\n  ): this {\n    this.minimap?.setStyle(style);\n    this.forceLanguageUpdate = true;\n\n    this.once(\"idle\", () => {\n      this.forceLanguageUpdate = false;\n    });\n\n    return super.setStyle(styleToStyle(style), options);\n  }\n\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(\n    layer:\n      | (LayerSpecification & {\n          source?: string | SourceSpecification;\n        })\n      | CustomLayerInterface,\n    beforeId?: string,\n  ): this {\n    this.minimap?.addLayer(layer, beforeId);\n    return super.addLayer(layer, beforeId);\n  }\n\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(id: string, beforeId?: string): this {\n    this.minimap?.moveLayer(id, beforeId);\n    return super.moveLayer(id, beforeId);\n  }\n\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(id: string): this {\n    this.minimap?.removeLayer(id);\n    return super.removeLayer(id);\n  }\n\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this {\n    this.minimap?.setLayerZoomRange(layerId, minzoom, maxzoom);\n    return super.setLayerZoomRange(layerId, minzoom, maxzoom);\n  }\n\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(layerId: string, filter?: FilterSpecification | null, options?: StyleSetterOptions): this {\n    this.minimap?.setFilter(layerId, filter, options);\n    return super.setFilter(layerId, filter, options);\n  }\n\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(layerId: string, name: string, value: any, options?: StyleSetterOptions): this {\n    this.minimap?.setPaintProperty(layerId, name, value, options);\n    return super.setPaintProperty(layerId, name, value, options);\n  }\n\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(layerId: string, name: string, value: any, options?: StyleSetterOptions): this {\n    this.minimap?.setLayoutProperty(layerId, name, value, options);\n    return super.setLayoutProperty(layerId, name, value, options);\n  }\n\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(glyphsUrl: string | null, options?: StyleSetterOptions): this {\n    this.minimap?.setGlyphs(glyphsUrl, options);\n    return super.setGlyphs(glyphsUrl, options);\n  }\n\n  private getStyleLanguage(): LanguageInfo | null {\n    if (!this.style.stylesheet.metadata) return null;\n    if (typeof this.style.stylesheet.metadata !== \"object\") return null;\n\n    if (\n      \"maptiler:language\" in this.style.stylesheet.metadata &&\n      typeof this.style.stylesheet.metadata[\"maptiler:language\"] === \"string\"\n    ) {\n      return getLanguageInfoFromFlag(this.style.stylesheet.metadata[\"maptiler:language\"]);\n    }\n\n    return null;\n  }\n\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(language: LanguageInfo | string): void {\n    this.minimap?.map?.setLanguage(language);\n    this.onStyleReady(() => {\n      this.setPrimaryLanguage(language);\n    });\n  }\n\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n\n  private setPrimaryLanguage(lang: LanguageInfo | string) {\n    const styleLanguage = this.getStyleLanguage();\n\n    // lang could be a string and we want to manipulate a LanguageInfo object instead\n    const language = toLanguageInfo(lang, Language);\n\n    if (!language) {\n      console.warn(`The language \"${language}\" is not supported.`);\n      return;\n    }\n\n    // If the language is set to `STYLE` (which is the SDK default), but the language defined in\n    // the style is `auto`, we need to bypass some verification and modify the languages anyway\n    if (\n      !(\n        language.flag === Language.STYLE.flag &&\n        styleLanguage &&\n        (styleLanguage.flag === Language.AUTO.flag || styleLanguage.flag === Language.VISITOR.flag)\n      )\n    ) {\n      if (language.flag !== Language.STYLE.flag) {\n        this.languageAlwaysBeenStyle = false;\n      }\n\n      if (this.languageAlwaysBeenStyle) {\n        return;\n      }\n\n      // No need to change the language\n      if (this.primaryLanguage === language && !this.forceLanguageUpdate) {\n        return;\n      }\n    }\n\n    if (this.primaryLanguage.flag === Language.STYLE_LOCK.flag) {\n      console.warn(\n        \"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\",\n      );\n      return;\n    }\n\n    this.primaryLanguage = language;\n    let languageNonStyle = language;\n\n    // STYLE needs to be translated into one of the other language,\n    // this is why it's addressed first\n    if (language.flag === Language.STYLE.flag) {\n      if (!styleLanguage) {\n        console.warn(\"The style has no default languages or has an invalid one.\");\n        return;\n      }\n\n      languageNonStyle = styleLanguage;\n    }\n\n    // may be overwritten below\n    let langStr = Language.LOCAL.flag;\n\n    // will be overwritten below\n    let replacer: ExpressionSpecification | string = `{${langStr}}`;\n\n    if (languageNonStyle.flag === Language.VISITOR.flag) {\n      langStr = getBrowserLanguage().flag;\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL.flag]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL.flag]],\n          [\"get\", Language.LOCAL.flag],\n\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL.flag],\n            { \"font-scale\": 1.1 },\n          ],\n        ],\n        [\"get\", Language.LOCAL.flag],\n      ];\n    } else if (languageNonStyle.flag === Language.VISITOR_ENGLISH.flag) {\n      langStr = Language.ENGLISH.flag;\n      replacer = [\n        \"case\",\n        [\"all\", [\"has\", langStr], [\"has\", Language.LOCAL.flag]],\n        [\n          \"case\",\n          [\"==\", [\"get\", langStr], [\"get\", Language.LOCAL.flag]],\n          [\"get\", Language.LOCAL.flag],\n\n          [\n            \"format\",\n            [\"get\", langStr],\n            { \"font-scale\": 0.8 },\n            \"\\n\",\n            [\"get\", Language.LOCAL.flag],\n            { \"font-scale\": 1.1 },\n          ],\n        ],\n        [\"get\", Language.LOCAL.flag],\n      ];\n    } else if (languageNonStyle.flag === Language.AUTO.flag) {\n      langStr = getBrowserLanguage().flag;\n      replacer = [\"case\", [\"has\", langStr], [\"get\", langStr], [\"get\", Language.LOCAL.flag]];\n    }\n\n    // This is for using the regular names as {name}\n    else if (languageNonStyle === Language.LOCAL) {\n      langStr = Language.LOCAL.flag;\n      replacer = `{${langStr}}`;\n    }\n\n    // This section is for the regular language ISO codes\n    else {\n      langStr = languageNonStyle.flag;\n      replacer = [\"case\", [\"has\", langStr], [\"get\", langStr], [\"get\", Language.LOCAL.flag]];\n    }\n\n    const { layers } = this.getStyle();\n\n    for (const genericLayer of layers) {\n      // Only symbole layer can have a layout with text-field\n      if (genericLayer.type !== \"symbol\") {\n        continue;\n      }\n\n      const layer = genericLayer as SymbolLayerSpecification;\n      const source = this.getSource(layer.source);\n\n      // Only a layer that is bound to a valid source is considered for language switching\n      if (!source) {\n        continue;\n      }\n\n      // Only source with a url are considered\n      if (!(\"url\" in source && typeof source.url === \"string\")) {\n        continue;\n      }\n\n      const sourceURL = new URL(source.url);\n\n      // Only layers managed by MapTiler are considered for language switch\n      if (sourceURL.host !== defaults.maptilerApiHost) {\n        continue;\n      }\n\n      const { id, layout } = layer;\n\n      if (!layout) {\n        continue;\n      }\n\n      if (!(\"text-field\" in layout)) {\n        continue;\n      }\n\n      const textFieldLayoutProp = this.getLayoutProperty(id, \"text-field\");\n\n      // If the label is not about a name, then we don't translate it\n      if (\n        typeof textFieldLayoutProp === \"string\" &&\n        (textFieldLayoutProp.toLowerCase().includes(\"ref\") || textFieldLayoutProp.toLowerCase().includes(\"housenumber\"))\n      ) {\n        continue;\n      }\n\n      this.setLayoutProperty(id, \"text-field\", replacer);\n    }\n  }\n\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage(): LanguageInfo {\n    return this.primaryLanguage;\n  }\n\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration(): number {\n    return this.terrainExaggeration;\n  }\n\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain(): boolean {\n    return this.isTerrainEnabled;\n  }\n\n  private growTerrain(exaggeration: number, durationMs = 1000) {\n    // This method assumes the terrain is already built\n    if (!this.terrain) {\n      return;\n    }\n\n    const startTime = performance.now();\n    // This is supposedly 0, but it could be something else (e.g. already in the middle of growing, or user defined other)\n    const currentExaggeration = this.terrain.exaggeration;\n    const deltaExaggeration = exaggeration - currentExaggeration;\n\n    // This is again called in a requestAnimationFrame ~loop, until the terrain has grown enough\n    // that it has reached the target\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n\n      // If the flattening animation is triggered while the growing animation\n      // is running, then the flattening animation is stopped\n      if (this.terrainFlattening) {\n        return;\n      }\n\n      // normalized value in interval [0, 1] of where we are currently in the animation loop\n      const positionInLoop = (performance.now() - startTime) / durationMs;\n\n      // The animation goes on until we reached 99% of the growing sequence duration\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = 1 - (1 - positionInLoop) ** 4;\n        const newExaggeration = currentExaggeration + exaggerationFactor * deltaExaggeration;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n        this.terrain.exaggeration = exaggeration;\n      }\n\n      // When growing the terrain, this is only necessary before rendering\n      this._elevationFreeze = false;\n      this.triggerRepaint();\n    };\n\n    this.terrainGrowing = true;\n    this.terrainFlattening = false;\n    requestAnimationFrame(updateExaggeration);\n  }\n\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(exaggeration = this.terrainExaggeration) {\n    if (exaggeration < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n\n    // This function is mapped to a map \"data\" event. It checks that the terrain\n    // tiles are loaded and when so, it starts an animation to make the terrain grow\n    const dataEventTerrainGrow = async (evt: MapTerrainDataEvent) => {\n      if (!this.terrain) {\n        return;\n      }\n\n      if (evt.type !== \"data\" || evt.dataType !== \"source\" || !(\"source\" in evt)) {\n        return;\n      }\n\n      if (evt.sourceId !== \"maptiler-terrain\") {\n        return;\n      }\n\n      const source = evt.source;\n\n      if (source.type !== \"raster-dem\") {\n        return;\n      }\n\n      if (!evt.isSourceLoaded) {\n        return;\n      }\n\n      // We shut this event off because we want it to happen only once.\n      // Yet, we cannot use the \"once\" method because only the last event of the series\n      // has `isSourceLoaded` true\n      this.off(\"data\", dataEventTerrainGrow);\n\n      this.growTerrain(exaggeration);\n    };\n\n    // This is put into a function so that it can be called regardless\n    // of the loading state of _this_ the map instance\n    const addTerrain = () => {\n      // When style is changed,\n      this.isTerrainEnabled = true;\n      this.terrainExaggeration = exaggeration;\n\n      // Mapping it to the \"data\" event so that we can check that the terrain\n      // growing starts only when terrain tiles are loaded (to reduce glitching)\n      this.on(\"data\", dataEventTerrainGrow);\n\n      this.addSource(defaults.terrainSourceId, {\n        type: \"raster-dem\",\n        url: defaults.terrainSourceURL,\n      });\n\n      // Setting up the terrain with a 0 exaggeration factor\n      // so it loads ~seamlessly and then can grow from there\n      this.setTerrain({\n        source: defaults.terrainSourceId,\n        exaggeration: 0,\n      });\n    };\n\n    // The terrain has already been loaded,\n    // we just update the exaggeration.\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = true;\n      this.growTerrain(exaggeration);\n      return;\n    }\n\n    if (this.loaded() || this.isTerrainEnabled) {\n      addTerrain();\n    } else {\n      this.once(\"load\", () => {\n        if (this.getTerrain() && this.getSource(defaults.terrainSourceId)) {\n          return;\n        }\n        addTerrain();\n      });\n    }\n  }\n\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    // It could be disabled already\n    if (!this.terrain) {\n      return;\n    }\n\n    this.isTerrainEnabled = false;\n    // this.stopFlattening = false;\n\n    // Duration of the animation in millisec\n    const animationLoopDuration = 1 * 1000;\n    const startTime = performance.now();\n    // This is supposedly 0, but it could be something else (e.g. already in the middle of growing, or user defined other)\n    const currentExaggeration = this.terrain.exaggeration;\n\n    // This is again called in a requestAnimationFrame ~loop, until the terrain has grown enough\n    // that it has reached the target\n    const updateExaggeration = () => {\n      if (!this.terrain) {\n        return;\n      }\n\n      // If the growing animation is triggered while flattening,\n      // then we exist the flatening\n      if (this.terrainGrowing) {\n        return;\n      }\n\n      // normalized value in interval [0, 1] of where we are currently in the animation loop\n      const positionInLoop = (performance.now() - startTime) / animationLoopDuration;\n\n      // At disabling, this should be togled fo both the setTerrain() (at the end of the animation)\n      // and also just before triggerRepain(), this is why we moved it this high\n      this._elevationFreeze = false;\n\n      // The animation goes on until we reached 99% of the growing sequence duration\n      if (positionInLoop < 0.99) {\n        const exaggerationFactor = (1 - positionInLoop) ** 4;\n        const newExaggeration = currentExaggeration * exaggerationFactor;\n        this.terrain.exaggeration = newExaggeration;\n        requestAnimationFrame(updateExaggeration);\n      } else {\n        this.terrain.exaggeration = 0;\n        this.terrainGrowing = false;\n        this.terrainFlattening = false;\n\n        // @ts-expect-error - https://github.com/maplibre/maplibre-gl-js/issues/2992\n        this.setTerrain();\n        if (this.getSource(defaults.terrainSourceId)) {\n          this.removeSource(defaults.terrainSourceId);\n        }\n      }\n\n      this.triggerRepaint();\n    };\n\n    this.terrainGrowing = false;\n    this.terrainFlattening = true;\n    requestAnimationFrame(updateExaggeration);\n  }\n\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(exaggeration: number, animate = true) {\n    if (!animate && this.terrain) {\n      this.terrainExaggeration = exaggeration;\n      this.terrain.exaggeration = exaggeration;\n      this.triggerRepaint();\n    } else {\n      this.enableTerrain(exaggeration);\n    }\n  }\n\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  private onStyleReady(cb: () => void) {\n    if (this.isStyleLoaded()) {\n      cb();\n    } else {\n      this.once(\"styledata\", () => {\n        cb();\n      });\n    }\n  }\n\n  async fitToIpBounds() {\n    const ipGeolocateResult = await geolocation.info();\n    this.fitBounds(ipGeolocateResult.country_bounds as [number, number, number, number], {\n      duration: 0,\n      padding: 100,\n    });\n  }\n\n  async centerOnIpPoint(zoom: number | undefined) {\n    const ipGeolocateResult = await geolocation.info();\n    this.jumpTo({\n      center: [ipGeolocateResult?.longitude ?? 0, ipGeolocateResult?.latitude ?? 0],\n      zoom: zoom || 11,\n    });\n  }\n\n  getCameraHash() {\n    const hashBin = new Float32Array(5);\n    const center = this.getCenter();\n    hashBin[0] = center.lng;\n    hashBin[1] = center.lat;\n    hashBin[2] = this.getZoom();\n    hashBin[3] = this.getPitch();\n    hashBin[4] = this.getBearing();\n    return Base64.fromUint8Array(new Uint8Array(hashBin.buffer));\n  }\n\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig(): SdkConfig {\n    return config;\n  }\n\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId(): string {\n    return MAPTILER_SESSION_ID;\n  }\n\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  override setTransformRequest(transformRequest: RequestTransformFunction): this {\n    super.setTransformRequest(combineTransformRequest(transformRequest));\n    return this;\n  }\n}\n","// Typescript port of https://github.com/mapbox/togeojson/\n// This includes KML and GPX parsing to GeoJSON\n\nexport interface Link {\n  href: string | null;\n}\n\nexport interface XMLProperties {\n  links?: Link[];\n}\n\nexport interface PlacemarkProperties {\n  name?: string;\n  address?: string;\n  styleUrl?: string;\n  description?: string;\n  styleHash?: string;\n  styleMapHash?: Record<string, string | null>;\n  timespan?: {\n    begin: string;\n    end: string;\n  };\n  timestamp?: string;\n  stroke?: string;\n  \"stroke-opacity\"?: number;\n  \"stroke-width\"?: number;\n  fill?: string;\n  \"fill-opacity\"?: number;\n  visibility?: string;\n  icon?: string;\n  coordTimes?: (string | null)[] | (string | null)[][];\n}\n\n/**\n * create a function that converts a string to XML\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n */\nexport function str2xml(str: string): Document {\n  if (typeof DOMParser !== \"undefined\") {\n    const doc = new DOMParser().parseFromString(str, \"application/xml\");\n\n    // If the input string was not valid XML\n    if (doc.querySelector(\"parsererror\")) {\n      throw new Error(\"The provided string is not valid XML\");\n    }\n\n    return doc;\n  }\n\n  throw new Error(\"No XML parser found\");\n}\n\n/**\n * Check one of the top level child node is of a given type (\"gpx\", \"kml\").\n * The check is not case sensitive.\n * @param doc\n * @param nodeName\n * @returns\n */\nexport function hasChildNodeWithName(doc: Document, nodeName: string): boolean {\n  if (!doc.hasChildNodes()) {\n    return false;\n  }\n\n  for (const childNode of Array.from(doc.childNodes)) {\n    const currentNodeName = childNode.nodeName;\n    if (typeof currentNodeName === \"string\" && currentNodeName.trim().toLowerCase() === nodeName.toLowerCase()) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * create a function that converts a XML to a string\n * https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer\n */\nexport function xml2str(node: Node): string {\n  if (typeof XMLSerializer !== \"undefined\") {\n    return new XMLSerializer().serializeToString(node);\n  }\n  throw new Error(\"No XML serializer found\");\n}\n\n/**\n * Given a XML document using the GPX spec, return GeoJSON\n */\nexport function gpx(doc: string | Document): GeoJSON.FeatureCollection {\n  const actualDoc = typeof doc === \"string\" ? str2xml(doc) : doc;\n\n  // The document is valid XML but not valid GPX (at least the first node is not)\n  if (!hasChildNodeWithName(actualDoc, \"gpx\")) {\n    throw new Error(\"The XML document is not valid GPX\");\n  }\n\n  const tracks = get(actualDoc, \"trk\");\n  const routes = get(actualDoc, \"rte\");\n  const waypoints = get(actualDoc, \"wpt\");\n  // a feature collection\n  const gj: GeoJSON.FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: [],\n  };\n  for (const track of Array.from(tracks)) {\n    const feature = getTrack(track);\n    if (feature) gj.features.push(feature);\n  }\n  for (const route of Array.from(routes)) {\n    const feature = getRoute(route);\n    if (feature) gj.features.push(feature);\n  }\n  for (const waypoint of Array.from(waypoints)) {\n    gj.features.push(getPoint(waypoint));\n  }\n  return gj;\n}\n\n/**\n * Given a XML document using the KML spec, return GeoJSON\n */\nexport function kml(doc: string | Document, xml2string?: (node: Node) => string): GeoJSON.FeatureCollection {\n  let actualDoc = doc;\n  if (typeof actualDoc === \"string\") actualDoc = str2xml(actualDoc);\n\n  // The document is valid XML but not valid KML (at leas the first node is not)\n  if (!hasChildNodeWithName(actualDoc, \"kml\")) {\n    throw new Error(\"The XML document is not valid KML\");\n  }\n\n  const gj: GeoJSON.FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: [],\n  };\n  // styleindex keeps track of hashed styles in order to match features\n  const styleIndex: Record<string, string> = {};\n  const styleByHash: Record<string, Element> = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex: Record<string, Record<string, string | null>> = {};\n  // all root placemarks in the file\n  const placemarks = get(actualDoc, \"Placemark\");\n  const styles = get(actualDoc, \"Style\");\n  const styleMaps = get(actualDoc, \"StyleMap\");\n\n  for (const style of Array.from(styles)) {\n    const hash = okhash(xml2string !== undefined ? xml2string(style) : xml2str(style)).toString(16);\n    styleIndex[`#${attr(style, \"id\")}`] = hash;\n    styleByHash[hash] = style;\n  }\n  for (const styleMap of Array.from(styleMaps)) {\n    styleIndex[`#${attr(styleMap, \"id\")}`] = okhash(\n      xml2string !== undefined ? xml2string(styleMap) : xml2str(styleMap),\n    ).toString(16);\n    const pairs = get(styleMap, \"Pair\");\n    const pairsMap: Record<string, string | null> = {};\n    for (const pair of Array.from(pairs)) {\n      pairsMap[nodeVal(get1(pair, \"key\")) ?? \"\"] = nodeVal(get1(pair, \"styleUrl\"));\n    }\n    styleMapIndex[`#${attr(styleMap, \"id\")}`] = pairsMap;\n  }\n  for (const placemark of Array.from(placemarks)) {\n    gj.features = gj.features.concat(getPlacemark(placemark, styleIndex, styleByHash, styleMapIndex));\n  }\n  return gj;\n}\n\n// parse color string to hex string with opacity. black with 100% opacity will be returned if no data found\nfunction kmlColor(v: string | null): [string, number] {\n  if (v === null) return [\"#000000\", 1];\n  let color = \"\";\n  let opacity = 1;\n  let validV = v;\n  if (validV.substring(0, 1) === \"#\") validV = validV.substring(1);\n  if (validV.length === 6 || validV.length === 3) color = validV;\n  if (validV.length === 8) {\n    opacity = Number.parseInt(validV.substring(0, 2), 16) / 255;\n    color = `#${validV.substring(6, 8)}${validV.substring(4, 6)}${validV.substring(2, 4)}`;\n  }\n  return [color ?? \"#000000\", opacity ?? 1];\n}\n\nfunction gxCoord(v: string): number[] {\n  return numarray(v.split(\" \"));\n}\n\n// grab coordinates and timestamps (when available) from the gx:Track extension\nfunction gxCoords(root: Document | Element): {\n  coords: number[][];\n  times: (string | null)[];\n} {\n  let elems = get(root, \"coord\");\n  const coords: number[][] = [];\n  const times: (string | null)[] = [];\n  if (elems.length === 0) elems = get(root, \"gx:coord\");\n  for (const elem of Array.from(elems)) {\n    coords.push(gxCoord(nodeVal(elem) ?? \"\"));\n  }\n  const timeElems = get(root, \"when\");\n  for (const timeElem of Array.from(timeElems)) times.push(nodeVal(timeElem));\n  return {\n    coords: coords,\n    times,\n  };\n}\n\n// get the geometry data and coordinate timestamps if available\nfunction getGeometry(root: Element): {\n  geoms: GeoJSON.Geometry[];\n  coordTimes: (string | null)[][];\n} {\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  const geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  // setup variables\n  let geomNode: Element;\n  let geomNodes: HTMLCollectionOf<Element>;\n  let i: number;\n  let j: number;\n  let k: number;\n  const geoms: GeoJSON.Geometry[] = [];\n  const coordTimes: (string | null)[][] = [];\n  // simple cases\n  if (get1(root, \"MultiGeometry\") !== null) {\n    return getGeometry(get1(root, \"MultiGeometry\") as Element);\n  }\n  if (get1(root, \"MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"MultiTrack\") as Element);\n  }\n  if (get1(root, \"gx:MultiTrack\") !== null) {\n    return getGeometry(get1(root, \"gx:MultiTrack\") as Element);\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = get(root, geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\")) ?? \"\"),\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\")) ?? \"\"),\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = get(geomNode, \"LinearRing\");\n          const coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\")) ?? \"\"));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords,\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords,\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return { geoms, coordTimes };\n}\n\n// build geojson feature sets with all their attributes and property data\nfunction getPlacemark(\n  root: Element,\n  styleIndex: Record<string, string>,\n  styleByHash: Record<string, Element>,\n  styleMapIndex: Record<string, Record<string, string | null>>,\n) {\n  const geomsAndTimes = getGeometry(root);\n  const properties: PlacemarkProperties & Record<string, string> = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  const visibility = get1(root, \"visibility\");\n\n  let i: number;\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n\n  if (!geomsAndTimes.geoms.length) return [];\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") styleUrl = `#${styleUrl}`;\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal ?? \"\"];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash ?? \"\"];\n    if (style) {\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n      const iconStyle = get1(style, \"IconStyle\");\n      if (iconStyle) {\n        const icon = get1(iconStyle, \"Icon\");\n        if (icon) {\n          const href = nodeVal(get1(icon, \"href\"));\n          if (href) properties.icon = href;\n        }\n      }\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    if (begin && end) properties.timespan = { begin, end };\n  }\n  if (timeStamp !== null) {\n    properties.timestamp = nodeVal(get1(timeStamp, \"when\")) ?? new Date().toISOString();\n  }\n  if (lineStyle !== null) {\n    const linestyles = kmlColor(nodeVal(get1(lineStyle, \"color\")));\n    const color = linestyles[0];\n    const opacity = linestyles[1];\n    const width = Number.parseFloat(nodeVal(get1(lineStyle, \"width\")) ?? \"\");\n    if (color) properties.stroke = color;\n    if (!Number.isNaN(opacity)) properties[\"stroke-opacity\"] = opacity;\n    if (!Number.isNaN(width)) properties[\"stroke-width\"] = width;\n  }\n  if (polyStyle) {\n    const polystyles = kmlColor(nodeVal(get1(polyStyle, \"color\")));\n    const pcolor = polystyles[0];\n    const popacity = polystyles[1];\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (pcolor) properties.fill = pcolor;\n    if (!Number.isNaN(popacity)) properties[\"fill-opacity\"] = popacity;\n    if (fill) properties[\"fill-opacity\"] = fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline) properties[\"stroke-opacity\"] = outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = get(extendedData, \"Data\");\n    const simpleDatas = get(extendedData, \"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\") ?? \"\"] = nodeVal(get1(datas[i], \"value\")) ?? \"\";\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\") ?? \"\"] = nodeVal(simpleDatas[i]) ?? \"\";\n    }\n  }\n  if (visibility !== null) {\n    properties.visibility = nodeVal(visibility) ?? \"\";\n  }\n  if (geomsAndTimes.coordTimes.length !== 0) {\n    properties.coordTimes =\n      geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n  }\n  const feature: GeoJSON.Feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms,\n          },\n    properties: properties,\n  };\n  if (attr(root, \"id\")) feature.id = attr(root, \"id\") ?? undefined;\n  return [feature];\n}\n\nfunction getPoints(\n  node: Element,\n  pointname: string,\n):\n  | undefined\n  | {\n      line: number[][];\n      times: string[];\n      heartRates: (number | null)[];\n    } {\n  const pts = get(node, pointname);\n  const line: number[][] = [];\n  const times: string[] = [];\n  let heartRates: (number | null)[] = [];\n  const ptsLength = pts.length;\n  if (ptsLength < 2) return; // Invalid line in GeoJSON\n  for (let i = 0; i < ptsLength; i++) {\n    const cPair = coordPair(pts[i]);\n    line.push(cPair.coordinates);\n    if (cPair.time) times.push(cPair.time);\n    if (cPair.heartRate || heartRates.length) {\n      if (heartRates.length === 0) heartRates = new Array(i).fill(null);\n      heartRates.push(cPair.heartRate);\n    }\n  }\n  return {\n    line: line,\n    times: times,\n    heartRates,\n  };\n}\n\nfunction getTrack(node: Element): undefined | GeoJSON.Feature {\n  const segments = get(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const heartRates: (number | null)[][] = [];\n  let line: any;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line !== undefined) {\n      if (line.line) track.push(line.line);\n      if (line.times && line.times.length) times.push(line.times);\n      if (heartRates.length || (line.heartRates && line.heartRates.length)) {\n        if (!heartRates.length) {\n          for (let s = 0; s < i; s++) {\n            heartRates.push(new Array(track[s].length).fill(null));\n          }\n        }\n        if (line.heartRates && line.heartRates.length) {\n          heartRates.push(line.heartRates);\n        } else {\n          heartRates.push(new Array(line.line.length).fill(null));\n        }\n      }\n    }\n  }\n  if (track.length === 0) return;\n  const properties: {\n    coordTimes?: string[] | string[][];\n    heartRates?: (number | null)[] | (number | null)[][];\n  } & XMLProperties &\n    Record<string, string | number> = {\n    ...getProperties(node),\n    ...getLineStyle(get1(node, \"extensions\")),\n  };\n  if (times.length !== 0) properties.coordTimes = track.length === 1 ? times[0] : times;\n  if (heartRates.length !== 0) {\n    properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n  }\n  if (track.length === 1) {\n    return {\n      type: \"Feature\",\n      properties,\n      geometry: {\n        type: \"LineString\",\n        coordinates: track[0],\n      },\n    };\n  }\n\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"MultiLineString\",\n      coordinates: track,\n    },\n  };\n}\n\nfunction getRoute(node: Element): GeoJSON.Feature | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (line === undefined) return;\n  const prop = {\n    ...getProperties(node),\n    ...getLineStyle(get1(node, \"extensions\")),\n  };\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getPoint(node: Element): GeoJSON.Feature {\n  const prop = { ...getProperties(node), ...getMulti(node, [\"sym\"]) };\n  return {\n    type: \"Feature\",\n    properties: prop,\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates,\n    },\n  };\n}\n\nfunction getLineStyle(extensions: Element | null): Record<string, string | number> {\n  const style: Record<string, string | number> = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\"));\n      const opacity = Number.parseFloat(nodeVal(get1(lineStyle, \"opacity\")) ?? \"0\");\n      const width = Number.parseFloat(nodeVal(get1(lineStyle, \"width\")) ?? \"0\");\n      if (color) style.stroke = color;\n      if (!Number.isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!Number.isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\nfunction getProperties(node: Element): XMLProperties & Record<string, string> {\n  const prop: XMLProperties & Record<string, string> = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n  const links = get(node, \"link\");\n  if (links.length !== 0) {\n    prop.links = [];\n    for (const l of Array.from(links)) {\n      const link = {\n        href: attr(l, \"href\"),\n        ...getMulti(l, [\"text\", \"type\"]),\n      };\n      prop.links.push(link);\n    }\n  }\n  return prop;\n}\n\nfunction okhash(x: string): number {\n  let h = 0;\n  if (!x || !x.length) return h;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\nfunction get(x: Document | Element, y: string): HTMLCollectionOf<Element> {\n  return x.getElementsByTagName(y);\n}\n\nfunction attr(x: Element, y: string): string | null {\n  return x.getAttribute(y);\n}\n\nfunction attrf(x: Element, y: string): number {\n  return Number.parseFloat(attr(x, y) ?? \"0\");\n}\n\nfunction get1(x: Element, y: string): Element | null {\n  const n = get(x, y);\n  return n.length ? n[0] : null;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\nfunction norm(el: Element): Element {\n  if (el.normalize) el.normalize();\n  return el;\n}\n\n// cast array x into numbers\nfunction numarray(x: string[]): number[] {\n  return x.map(Number.parseFloat).map((n) => (Number.isNaN(n) ? null : n)) as number[];\n}\n\n// get the content of a text node, if any\nfunction nodeVal(x: Element | null): string | null {\n  if (x) norm(x);\n  return x && x.textContent;\n}\n\n// get the contents of multiple text nodes, if present\nfunction getMulti(x: Element, ys: string[]): Record<string, string> {\n  const o: Record<string, string> = {};\n  let n: Element | null;\n  let k: number;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n) ?? \"\";\n  }\n  return o;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v: string): number[] {\n  return numarray(v.replace(/\\s*/g, \"\").split(\",\"));\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v: string): number[][] {\n  const coords = v.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/);\n  const out = [];\n  for (const coord of coords) out.push(coord1(coord));\n  return out;\n}\n\n// build a set of coordinates, timestamps, and heartrate\nfunction coordPair(x: Element): {\n  coordinates: number[];\n  time: string | null;\n  heartRate: number | null;\n} {\n  const ll = [attrf(x, \"lon\"), attrf(x, \"lat\")];\n  const ele = get1(x, \"ele\");\n  // handle namespaced attribute in browser\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e: number;\n  if (ele) {\n    e = Number.parseFloat(nodeVal(ele) ?? \"0\");\n    if (!Number.isNaN(e)) ll.push(e);\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate !== null ? Number.parseFloat(nodeVal(heartRate) ?? \"0\") : null,\n  };\n}\n\nexport function gpxOrKml(doc: string | Document): GeoJSON.FeatureCollection | null {\n  let actualDoc = doc;\n  try {\n    // Converting only once rather than in each converter\n    if (typeof actualDoc === \"string\") actualDoc = str2xml(actualDoc);\n  } catch (e) {\n    // The doc is a string but not valid XML\n    return null;\n  }\n\n  try {\n    const result = gpx(actualDoc);\n    return result;\n  } catch (e) {\n    // The doc is valid XML but not valid GPX\n  }\n\n  try {\n    const result = kml(actualDoc);\n    return result;\n  } catch (e) {\n    // The doc is valid XML but not valid KML\n  }\n\n  // At this point, the doc is not of a compatible vector format\n  return null;\n}\n","export type RgbaColor = [number, number, number] | [number, number, number, number];\n\nexport type ColorStop = {\n  /**\n   * The \"value\" at which this ColorStop should be applied.\n   */\n  value: number;\n  /**\n   * RGB[A] - Array of 3-4 numbers. 0-255 per channel.\n   */\n  color: RgbaColor;\n};\n\n/**\n * A RGBA color as per the array definition\n */\nexport type ArrayColor = [number, number, number, number];\n\n/**\n * A color ramp stop as per array definition\n */\nexport type ArrayColorRampStop = [\n  /**\n   * Real world value in a real world unit\n   */\n  number,\n  /**\n   * Color RGBA\n   */\n  ArrayColor,\n];\n\n/**\n * A color ramp as per array definition\n */\nexport type ArrayColorRamp = Array<ArrayColorRampStop>;\n\nexport type ColorRampOptions = {\n  /**\n   * The value the colorramp starts\n   */\n  min?: number;\n\n  /**\n   * The value the colorramp ends\n   */\n  max?: number;\n\n  /**\n   * Some color stops to copy from\n   */\n  stops?: Array<ColorStop>;\n};\n\nfunction componentToHex(c: number): string {\n  const hex = c.toString(16);\n  return hex.length === 1 ? `0${hex}` : hex;\n}\n\nfunction rgbToHex(rgb: RgbaColor): string {\n  return `#${componentToHex(rgb[0])}${componentToHex(rgb[1])}${componentToHex(rgb[2])}${rgb.length === 4 ? componentToHex(rgb[3]) : \"\"}`;\n}\n\nexport class ColorRamp extends Array<ColorStop> {\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(cr: ArrayColorRamp): ColorRamp {\n    return new ColorRamp({\n      stops: cr.map((cs: ArrayColorRampStop) => ({\n        value: cs[0],\n        color: cs[1],\n      })),\n    });\n  }\n\n  private min = 0;\n  private max = 1;\n\n  constructor(options: ColorRampOptions = {}) {\n    super();\n\n    if (\"min\" in options) {\n      this.min = options.min as number;\n    }\n\n    if (\"max\" in options) {\n      this.max = options.max as number;\n    }\n\n    if (\"stops\" in options) {\n      this.setStops(options.stops as ColorStop[], { clone: false });\n    }\n  }\n\n  setStops(stops: Array<ColorStop>, options: { clone?: boolean } = { clone: true }): ColorRamp {\n    const colorRamp = options.clone ? this.clone() : this;\n\n    colorRamp.length = 0;\n\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0; i < stops.length; i += 1) {\n      min = Math.min(min, stops[i].value);\n      max = Math.max(max, stops[i].value);\n\n      colorRamp.push({\n        value: stops[i].value,\n        color: stops[i].color.slice(), // we want to make sure we do a deep copy and not a reference\n      } as ColorStop);\n    }\n\n    colorRamp.sort((a: ColorStop, b: ColorStop) => (a.value < b.value ? -1 : 1));\n\n    this.min = min;\n    this.max = max;\n\n    return colorRamp;\n  }\n\n  scale(min: number, max: number, options: { clone?: boolean } = { clone: true }): ColorRamp {\n    const clone = options.clone;\n\n    const currentMin = this[0].value;\n    const currentMax = this.at(-1).value;\n    const currentSpan = currentMax - currentMin;\n    const newSpan = max - min;\n    const stops = [];\n\n    for (let i = 0; i < this.length; i += 1) {\n      const currentValue = this[i].value;\n      const normalizedValue = (currentValue - currentMin) / currentSpan; // putting the value in the interval [0, 1]\n      const newValue = normalizedValue * newSpan + min; // putting the value in the new interval\n\n      if (clone) {\n        stops.push({\n          value: newValue,\n          color: this[i].color.slice(),\n        } as ColorStop);\n      } else {\n        this[i].value = newValue;\n      }\n    }\n\n    return clone ? new ColorRamp({ stops }) : this;\n  }\n\n  // for some reason, I had to reimplement this\n  at(pos: number) {\n    if (pos < 0) {\n      return this[this.length + pos];\n    }\n\n    return this[pos];\n  }\n\n  clone(): ColorRamp {\n    return new ColorRamp({ stops: this.getRawColorStops() });\n  }\n\n  getRawColorStops(): Array<ColorStop> {\n    const stops = [];\n\n    for (let i = 0; i < this.length; i += 1) {\n      stops.push({ value: this[i].value, color: this[i].color });\n    }\n\n    return stops;\n  }\n\n  reverse(options: { clone?: boolean } = { clone: true }): ColorRamp {\n    const colorRamp = options.clone ? this.clone() : this;\n\n    for (let i = 0; i < ~~(colorRamp.length / 2); i += 1) {\n      const c = colorRamp[i].color;\n      colorRamp[i].color = colorRamp.at(-(i + 1)).color;\n      colorRamp.at(-(i + 1)).color = c;\n    }\n    return colorRamp;\n  }\n\n  getBounds(): { min: number; max: number } {\n    return { min: this.min, max: this.max };\n  }\n\n  getColor(value: number, options: { smooth?: boolean } = { smooth: true }): RgbaColor {\n    if (value <= this[0].value) {\n      return this[0].color;\n    }\n\n    if (value >= this.at(-1).value) {\n      return this.at(-1).color;\n    }\n\n    for (let i = 0; i < this.length - 1; i += 1) {\n      if (value > this[i + 1].value) {\n        continue;\n      }\n\n      const colorBefore = this[i].color;\n\n      if (!options.smooth) {\n        return colorBefore.slice() as RgbaColor;\n      }\n\n      const valueBefore = this[i].value;\n      const valueAfter = this[i + 1].value;\n      const colorAfter = this[i + 1].color;\n\n      const beforeRatio = (valueAfter - value) / (valueAfter - valueBefore);\n      return colorBefore.map((chan, i) =>\n        Math.round(chan * beforeRatio + colorAfter[i] * (1 - beforeRatio)),\n      ) as RgbaColor;\n    }\n\n    return [0, 0, 0] as RgbaColor;\n  }\n\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(\n    value: number,\n    options: { smooth?: boolean; withAlpha?: boolean } = {\n      smooth: true,\n      withAlpha: false,\n    },\n  ): string {\n    return rgbToHex(this.getColor(value, options));\n  }\n\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(value: number, options: { smooth?: boolean } = { smooth: true }): RgbaColor {\n    const bounds = this.getBounds();\n    return this.getColor(bounds.min + value * (bounds.max - bounds.min), options);\n  }\n\n  getCanvasStrip(\n    options: { horizontal?: boolean; size?: number; smooth?: boolean } = {\n      horizontal: true,\n      size: 512,\n      smooth: true,\n    },\n  ) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = options.horizontal ? (options.size as number) : 1;\n    canvas.height = options.horizontal ? 1 : (options.size as number);\n\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) throw new Error(\"Canvs context is missing\");\n\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const imageDataArray = imageData.data;\n\n    const size = options.size as number;\n    const startValue = this[0].value;\n    const endValue = this.at(-1).value;\n    const valueSpan = endValue - startValue;\n    const valueStep = valueSpan / size;\n\n    for (let i = 0; i < size; i += 1) {\n      const color = this.getColor(startValue + i * valueStep, {\n        smooth: options.smooth,\n      });\n      imageDataArray[i * 4] = color[0];\n      imageDataArray[i * 4 + 1] = color[1];\n      imageDataArray[i * 4 + 2] = color[2];\n      imageDataArray[i * 4 + 3] = color.length > 3 ? (color[3] as number) : 255;\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(\n    method: \"ease-in-square\" | \"ease-out-square\" | \"ease-in-sqrt\" | \"ease-out-sqrt\" | \"ease-in-exp\" | \"ease-out-exp\",\n    samples = 15,\n  ): ColorRamp {\n    const inputBounds = this.getBounds();\n    const inputNormalized = this.scale(0, 1);\n    const step = 1 / (samples - 1);\n\n    let stops: Array<ColorStop>;\n\n    if (method === \"ease-in-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = x ** 2;\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-square\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - (1 - x) ** 2;\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = x ** 0.5;\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-sqrt\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - (1 - x) ** 0.5;\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-out-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 1 - 2 ** (-10 * x);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else if (method === \"ease-in-exp\") {\n      stops = Array.from({ length: samples }, (_, i) => {\n        const x = i * step;\n        const y = 2 ** (10 * x - 10);\n        const color = inputNormalized.getColor(y);\n        return { value: x, color };\n      });\n    } else {\n      throw new Error(\"Invalid ressampling method.\");\n    }\n\n    const outputNormalized = new ColorRamp({ stops });\n    const output = outputNormalized.scale(inputBounds.min, inputBounds.max);\n    return output;\n  }\n\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart(): ColorRamp {\n    const stops = this.getRawColorStops();\n    stops.unshift({\n      value: stops[0].value,\n      color: stops[0].color.slice() as RgbaColor,\n    });\n    stops[1].value += 0.001;\n\n    for (const s of stops) {\n      if (s.color.length === 3) {\n        s.color.push(255);\n      }\n    }\n\n    stops[0].color[3] = 0;\n\n    return new ColorRamp({ stops });\n  }\n\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart(): boolean {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\n\n/**\n * This is a collection of built-in color ramps. They are all defined in the range [0, 1]\n * but can be scaled or reversed to fit specific usages.\n */\nexport const ColorRampCollection = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0, 0] },\n      { value: 1, color: [0, 0, 0, 0] },\n    ],\n  }),\n\n  GRAY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 131] },\n      { value: 0.125, color: [0, 60, 170] },\n      { value: 0.375, color: [5, 255, 255] },\n      { value: 0.625, color: [255, 255, 0] },\n      { value: 0.875, color: [250, 0, 0] },\n      { value: 1, color: [128, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 0.169, color: [253, 255, 2] },\n      { value: 0.173, color: [247, 255, 2] },\n      { value: 0.337, color: [0, 252, 4] },\n      { value: 0.341, color: [0, 252, 10] },\n      { value: 0.506, color: [1, 249, 255] },\n      { value: 0.671, color: [2, 0, 253] },\n      { value: 0.675, color: [8, 0, 253] },\n      { value: 0.839, color: [255, 0, 251] },\n      { value: 0.843, color: [255, 0, 245] },\n      { value: 1, color: [255, 0, 6] },\n    ],\n  }),\n\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.3, color: [230, 0, 0] },\n      { value: 0.6, color: [255, 210, 0] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 255] },\n      { value: 1, color: [255, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 128, 102] },\n      { value: 1, color: [255, 255, 102] },\n    ],\n  }),\n\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new ColorRamp({\n    stops: [\n      { value: 0, color: [255, 0, 0] },\n      { value: 1, color: [255, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [0, 255, 128] },\n    ],\n  }),\n\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.376, color: [84, 84, 116] },\n      { value: 0.753, color: [169, 200, 200] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.804, color: [255, 160, 102] },\n      { value: 1, color: [255, 199, 127] },\n    ],\n  }),\n\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [8, 29, 88] },\n      { value: 0.125, color: [37, 52, 148] },\n      { value: 0.25, color: [34, 94, 168] },\n      { value: 0.375, color: [29, 145, 192] },\n      { value: 0.5, color: [65, 182, 196] },\n      { value: 0.625, color: [127, 205, 187] },\n      { value: 0.75, color: [199, 233, 180] },\n      { value: 0.875, color: [237, 248, 217] },\n      { value: 1, color: [255, 255, 217] },\n    ],\n  }),\n\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 68, 27] },\n      { value: 0.125, color: [0, 109, 44] },\n      { value: 0.25, color: [35, 139, 69] },\n      { value: 0.375, color: [65, 171, 93] },\n      { value: 0.5, color: [116, 196, 118] },\n      { value: 0.625, color: [161, 217, 155] },\n      { value: 0.75, color: [199, 233, 192] },\n      { value: 0.875, color: [229, 245, 224] },\n      { value: 1, color: [247, 252, 245] },\n    ],\n  }),\n\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new ColorRamp({\n    stops: [\n      { value: 0, color: [128, 0, 38] },\n      { value: 0.125, color: [189, 0, 38] },\n      { value: 0.25, color: [227, 26, 28] },\n      { value: 0.375, color: [252, 78, 42] },\n      { value: 0.5, color: [253, 141, 60] },\n      { value: 0.625, color: [254, 178, 76] },\n      { value: 0.75, color: [254, 217, 118] },\n      { value: 0.875, color: [255, 237, 160] },\n      { value: 1, color: [255, 255, 204] },\n    ],\n  }),\n\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 1, color: [255, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new ColorRamp({\n    stops: [\n      { value: 0, color: [5, 10, 172] },\n      { value: 0.35, color: [106, 137, 247] },\n      { value: 0.5, color: [190, 190, 190] },\n      { value: 0.6, color: [220, 170, 132] },\n      { value: 0.7, color: [230, 145, 90] },\n      { value: 1, color: [178, 10, 28] },\n    ],\n  }),\n\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 255] },\n      { value: 0.1, color: [51, 153, 255] },\n      { value: 0.2, color: [102, 204, 255] },\n      { value: 0.3, color: [153, 204, 255] },\n      { value: 0.4, color: [204, 204, 255] },\n      { value: 0.5, color: [255, 255, 255] },\n      { value: 0.6, color: [255, 204, 255] },\n      { value: 0.7, color: [255, 153, 255] },\n      { value: 0.8, color: [255, 102, 204] },\n      { value: 0.9, color: [255, 102, 102] },\n      { value: 1, color: [255, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new ColorRamp({\n    stops: [\n      { value: 0, color: [150, 0, 90] },\n      { value: 0.125, color: [0, 0, 200] },\n      { value: 0.25, color: [0, 25, 255] },\n      { value: 0.375, color: [0, 152, 255] },\n      { value: 0.5, color: [44, 255, 150] },\n      { value: 0.625, color: [151, 255, 0] },\n      { value: 0.75, color: [255, 234, 0] },\n      { value: 0.875, color: [255, 111, 0] },\n      { value: 1, color: [255, 0, 0] },\n    ],\n  }),\n\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new ColorRamp({\n    stops: [\n      { value: 0, color: [12, 51, 131] },\n      { value: 0.25, color: [10, 136, 186] },\n      { value: 0.5, color: [242, 211, 56] },\n      { value: 0.75, color: [242, 143, 56] },\n      { value: 1, color: [217, 30, 30] },\n    ],\n  }),\n\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.2, color: [230, 0, 0] },\n      { value: 0.4, color: [230, 210, 0] },\n      { value: 0.7, color: [255, 255, 255] },\n      { value: 1, color: [160, 200, 255] },\n    ],\n  }),\n\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 130] },\n      { value: 0.1, color: [0, 180, 180] },\n      { value: 0.2, color: [40, 210, 40] },\n      { value: 0.4, color: [230, 230, 50] },\n      { value: 0.6, color: [120, 70, 20] },\n      { value: 1, color: [255, 255, 255] },\n    ],\n  }),\n\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.15, color: [30, 0, 100] },\n      { value: 0.4, color: [120, 0, 100] },\n      { value: 0.6, color: [160, 90, 0] },\n      { value: 0.8, color: [230, 200, 0] },\n      { value: 1, color: [255, 250, 220] },\n    ],\n  }),\n\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [68, 1, 84] },\n      { value: 0.13, color: [71, 44, 122] },\n      { value: 0.25, color: [59, 81, 139] },\n      { value: 0.38, color: [44, 113, 142] },\n      { value: 0.5, color: [33, 144, 141] },\n      { value: 0.63, color: [39, 173, 129] },\n      { value: 0.75, color: [92, 200, 99] },\n      { value: 0.88, color: [170, 220, 50] },\n      { value: 1, color: [253, 231, 37] },\n    ],\n  }),\n\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [31, 12, 72] },\n      { value: 0.25, color: [85, 15, 109] },\n      { value: 0.38, color: [136, 34, 106] },\n      { value: 0.5, color: [186, 54, 85] },\n      { value: 0.63, color: [227, 89, 51] },\n      { value: 0.75, color: [249, 140, 10] },\n      { value: 0.88, color: [249, 201, 50] },\n      { value: 1, color: [252, 255, 164] },\n    ],\n  }),\n\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 4] },\n      { value: 0.13, color: [28, 16, 68] },\n      { value: 0.25, color: [79, 18, 123] },\n      { value: 0.38, color: [129, 37, 129] },\n      { value: 0.5, color: [181, 54, 122] },\n      { value: 0.63, color: [229, 80, 100] },\n      { value: 0.75, color: [251, 135, 97] },\n      { value: 0.88, color: [254, 194, 135] },\n      { value: 1, color: [252, 253, 191] },\n    ],\n  }),\n\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new ColorRamp({\n    stops: [\n      { value: 0, color: [13, 8, 135] },\n      { value: 0.13, color: [75, 3, 161] },\n      { value: 0.25, color: [125, 3, 168] },\n      { value: 0.38, color: [168, 34, 150] },\n      { value: 0.5, color: [203, 70, 121] },\n      { value: 0.63, color: [229, 107, 93] },\n      { value: 0.75, color: [248, 148, 65] },\n      { value: 0.88, color: [253, 195, 40] },\n      { value: 1, color: [240, 249, 33] },\n    ],\n  }),\n\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [172, 0, 187] },\n      { value: 0.25, color: [219, 0, 170] },\n      { value: 0.38, color: [255, 0, 130] },\n      { value: 0.5, color: [255, 63, 74] },\n      { value: 0.63, color: [255, 123, 0] },\n      { value: 0.75, color: [234, 176, 0] },\n      { value: 0.88, color: [190, 228, 0] },\n      { value: 1, color: [147, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.13, color: [116, 0, 218] },\n      { value: 0.25, color: [98, 74, 237] },\n      { value: 0.38, color: [68, 146, 231] },\n      { value: 0.5, color: [0, 204, 197] },\n      { value: 0.63, color: [0, 247, 146] },\n      { value: 0.75, color: [0, 255, 88] },\n      { value: 0.88, color: [40, 255, 8] },\n      { value: 1, color: [147, 255, 0] },\n    ],\n  }),\n\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new ColorRamp({\n    stops: [\n      { value: 0, color: [125, 0, 179] },\n      { value: 0.1, color: [199, 0, 180] },\n      { value: 0.2, color: [255, 0, 121] },\n      { value: 0.3, color: [255, 108, 0] },\n      { value: 0.4, color: [222, 194, 0] },\n      { value: 0.5, color: [150, 255, 0] },\n      { value: 0.6, color: [0, 255, 55] },\n      { value: 0.7, color: [0, 246, 150] },\n      { value: 0.8, color: [50, 167, 222] },\n      { value: 0.9, color: [103, 51, 235] },\n      { value: 1, color: [124, 0, 186] },\n    ],\n  }),\n\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new ColorRamp({\n    stops: [\n      { value: 0, color: [40, 26, 44] },\n      { value: 0.13, color: [59, 49, 90] },\n      { value: 0.25, color: [64, 76, 139] },\n      { value: 0.38, color: [63, 110, 151] },\n      { value: 0.5, color: [72, 142, 158] },\n      { value: 0.63, color: [85, 174, 163] },\n      { value: 0.75, color: [120, 206, 163] },\n      { value: 0.88, color: [187, 230, 172] },\n      { value: 1, color: [253, 254, 204] },\n    ],\n  }),\n\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new ColorRamp({\n    stops: [\n      { value: 0, color: [47, 15, 62] },\n      { value: 0.13, color: [87, 23, 86] },\n      { value: 0.25, color: [130, 28, 99] },\n      { value: 0.38, color: [171, 41, 96] },\n      { value: 0.5, color: [206, 67, 86] },\n      { value: 0.63, color: [230, 106, 84] },\n      { value: 0.75, color: [242, 149, 103] },\n      { value: 0.88, color: [249, 193, 135] },\n      { value: 1, color: [254, 237, 176] },\n    ],\n  }),\n\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new ColorRamp({\n    stops: [\n      { value: 0, color: [18, 36, 20] },\n      { value: 0.13, color: [25, 63, 41] },\n      { value: 0.25, color: [24, 91, 59] },\n      { value: 0.38, color: [13, 119, 72] },\n      { value: 0.5, color: [18, 148, 80] },\n      { value: 0.63, color: [80, 173, 89] },\n      { value: 0.75, color: [132, 196, 122] },\n      { value: 0.88, color: [175, 221, 162] },\n      { value: 1, color: [215, 249, 208] },\n    ],\n  }),\n\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [54, 14, 36] },\n      { value: 0.13, color: [89, 23, 80] },\n      { value: 0.25, color: [110, 45, 132] },\n      { value: 0.38, color: [120, 77, 178] },\n      { value: 0.5, color: [120, 113, 213] },\n      { value: 0.63, color: [115, 151, 228] },\n      { value: 0.75, color: [134, 185, 227] },\n      { value: 0.88, color: [177, 214, 227] },\n      { value: 1, color: [230, 241, 241] },\n    ],\n  }),\n\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [30, 4, 110] },\n      { value: 0.13, color: [47, 14, 176] },\n      { value: 0.25, color: [41, 45, 236] },\n      { value: 0.38, color: [25, 99, 212] },\n      { value: 0.5, color: [68, 131, 200] },\n      { value: 0.63, color: [114, 156, 197] },\n      { value: 0.75, color: [157, 181, 203] },\n      { value: 0.88, color: [200, 208, 216] },\n      { value: 1, color: [241, 237, 236] },\n    ],\n  }),\n\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new ColorRamp({\n    stops: [\n      { value: 0, color: [60, 9, 18] },\n      { value: 0.13, color: [100, 17, 27] },\n      { value: 0.25, color: [142, 20, 29] },\n      { value: 0.38, color: [177, 43, 27] },\n      { value: 0.5, color: [192, 87, 63] },\n      { value: 0.63, color: [205, 125, 105] },\n      { value: 0.75, color: [216, 162, 148] },\n      { value: 0.88, color: [227, 199, 193] },\n      { value: 1, color: [241, 237, 236] },\n    ],\n  }),\n\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [64, 5, 5] },\n      { value: 0.13, color: [106, 6, 15] },\n      { value: 0.25, color: [144, 26, 7] },\n      { value: 0.38, color: [168, 64, 3] },\n      { value: 0.5, color: [188, 100, 4] },\n      { value: 0.63, color: [206, 136, 11] },\n      { value: 0.75, color: [220, 174, 25] },\n      { value: 0.88, color: [231, 215, 44] },\n      { value: 1, color: [248, 254, 105] },\n    ],\n  }),\n\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new ColorRamp({\n    stops: [\n      { value: 0, color: [51, 20, 24] },\n      { value: 0.13, color: [90, 32, 35] },\n      { value: 0.25, color: [129, 44, 34] },\n      { value: 0.38, color: [159, 68, 25] },\n      { value: 0.5, color: [182, 99, 19] },\n      { value: 0.63, color: [199, 134, 22] },\n      { value: 0.75, color: [212, 171, 35] },\n      { value: 0.88, color: [221, 210, 54] },\n      { value: 1, color: [225, 253, 75] },\n    ],\n  }),\n\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new ColorRamp({\n    stops: [\n      { value: 0, color: [145, 105, 18] },\n      { value: 0.13, color: [184, 71, 38] },\n      { value: 0.25, color: [186, 58, 115] },\n      { value: 0.38, color: [160, 71, 185] },\n      { value: 0.5, color: [110, 97, 218] },\n      { value: 0.63, color: [50, 123, 164] },\n      { value: 0.75, color: [31, 131, 110] },\n      { value: 0.88, color: [77, 129, 34] },\n      { value: 1, color: [145, 105, 18] },\n    ],\n  }),\n\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [42, 24, 108] },\n      { value: 0.13, color: [33, 50, 162] },\n      { value: 0.25, color: [15, 90, 145] },\n      { value: 0.38, color: [40, 118, 137] },\n      { value: 0.5, color: [59, 146, 135] },\n      { value: 0.63, color: [79, 175, 126] },\n      { value: 0.75, color: [120, 203, 104] },\n      { value: 0.88, color: [193, 221, 100] },\n      { value: 1, color: [253, 239, 154] },\n    ],\n  }),\n\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new ColorRamp({\n    stops: [\n      { value: 0, color: [4, 35, 51] },\n      { value: 0.13, color: [23, 51, 122] },\n      { value: 0.25, color: [85, 59, 157] },\n      { value: 0.38, color: [129, 79, 143] },\n      { value: 0.5, color: [175, 95, 130] },\n      { value: 0.63, color: [222, 112, 101] },\n      { value: 0.75, color: [249, 146, 66] },\n      { value: 0.88, color: [249, 196, 65] },\n      { value: 1, color: [232, 250, 91] },\n    ],\n  }),\n\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new ColorRamp({\n    stops: [\n      { value: 0, color: [34, 31, 27] },\n      { value: 0.13, color: [65, 50, 41] },\n      { value: 0.25, color: [98, 69, 52] },\n      { value: 0.38, color: [131, 89, 57] },\n      { value: 0.5, color: [161, 112, 59] },\n      { value: 0.63, color: [185, 140, 66] },\n      { value: 0.75, color: [202, 174, 88] },\n      { value: 0.88, color: [216, 209, 126] },\n      { value: 1, color: [233, 246, 171] },\n    ],\n  }),\n\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new ColorRamp({\n    stops: [\n      { value: 0, color: [17, 32, 64] },\n      { value: 0.13, color: [35, 52, 116] },\n      { value: 0.25, color: [29, 81, 156] },\n      { value: 0.38, color: [31, 113, 162] },\n      { value: 0.5, color: [50, 144, 169] },\n      { value: 0.63, color: [87, 173, 176] },\n      { value: 0.75, color: [149, 196, 189] },\n      { value: 0.88, color: [203, 221, 211] },\n      { value: 1, color: [254, 251, 230] },\n    ],\n  }),\n\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new ColorRamp({\n    stops: [\n      { value: 0, color: [23, 35, 19] },\n      { value: 0.13, color: [24, 64, 38] },\n      { value: 0.25, color: [11, 95, 45] },\n      { value: 0.38, color: [39, 123, 35] },\n      { value: 0.5, color: [95, 146, 12] },\n      { value: 0.63, color: [152, 165, 18] },\n      { value: 0.75, color: [201, 186, 69] },\n      { value: 0.88, color: [233, 216, 137] },\n      { value: 1, color: [255, 253, 205] },\n    ],\n  }),\n\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 0, 0] },\n      { value: 0.07, color: [22, 5, 59] },\n      { value: 0.13, color: [60, 4, 105] },\n      { value: 0.2, color: [109, 1, 135] },\n      { value: 0.27, color: [161, 0, 147] },\n      { value: 0.33, color: [210, 2, 142] },\n      { value: 0.4, color: [251, 11, 123] },\n      { value: 0.47, color: [255, 29, 97] },\n      { value: 0.53, color: [255, 54, 69] },\n      { value: 0.6, color: [255, 85, 46] },\n      { value: 0.67, color: [255, 120, 34] },\n      { value: 0.73, color: [255, 157, 37] },\n      { value: 0.8, color: [241, 191, 57] },\n      { value: 0.87, color: [224, 220, 93] },\n      { value: 0.93, color: [218, 241, 142] },\n      { value: 1, color: [227, 253, 198] },\n    ],\n  }),\n\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new ColorRamp({\n    stops: [\n      { value: 0, color: [0, 32, 77, 255] },\n      { value: 0.125, color: [5, 54, 110, 255] },\n      { value: 0.25, color: [65, 77, 108, 255] },\n      { value: 0.375, color: [97, 100, 111, 255] },\n      { value: 0.5, color: [125, 124, 121, 255] },\n      { value: 0.625, color: [156, 149, 120, 255] },\n      { value: 0.75, color: [190, 175, 111, 255] },\n      { value: 0.875, color: [225, 204, 94, 255] },\n      { value: 1, color: [255, 235, 70, 255] },\n    ],\n  }),\n\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new ColorRamp({\n    stops: [\n      { value: 0, color: [48, 18, 59, 255] },\n      { value: 0.125, color: [70, 107, 227, 255] },\n      { value: 0.25, color: [40, 187, 236, 255] },\n      { value: 0.375, color: [49, 242, 153, 255] },\n      { value: 0.5, color: [162, 252, 60, 255] },\n      { value: 0.625, color: [237, 208, 58, 255] },\n      { value: 0.75, color: [251, 128, 34, 255] },\n      { value: 0.875, color: [210, 49, 5, 255] },\n      { value: 1, color: [122, 4, 3, 255] },\n    ],\n  }),\n\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new ColorRamp({\n    stops: [\n      { value: 0, color: [250, 235, 221, 0] },\n      { value: 0.133, color: [250, 235, 221, 255] },\n      { value: 0.266, color: [246, 170, 130, 255] },\n      { value: 0.4, color: [240, 96, 67, 255] },\n      { value: 0.533, color: [203, 27, 79, 255] },\n      { value: 0.666, color: [132, 30, 90, 255] },\n      { value: 0.8, color: [63, 27, 68, 255] },\n      { value: 1, color: [3, 5, 26, 255] },\n    ],\n  }),\n\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new ColorRamp({\n    stops: [\n      { value: 0, color: [11, 4, 5, 255] },\n      { value: 0.125, color: [43, 28, 53, 255] },\n      { value: 0.25, color: [62, 53, 107, 255] },\n      { value: 0.375, color: [59, 86, 152, 255] },\n      { value: 0.5, color: [53, 123, 162, 255] },\n      { value: 0.625, color: [53, 158, 170, 255] },\n      { value: 0.75, color: [73, 193, 173, 255] },\n      { value: 0.875, color: [150, 221, 181, 255] },\n      { value: 1, color: [222, 245, 229, 255] },\n    ],\n  }),\n};\n","import type { Map as MapSDK } from \"../Map\";\n\n/**\n * Takes a screenshot (PNG file) of the curent map view.\n * Depending on the options, this function can automatically trigger a download of te file.\n */\nexport async function takeScreenshot(\n  map: MapSDK,\n  options: {\n    /**\n     * If `true`, this function will trigger a download in addition to returning a blob.\n     * Default: `false`\n     */\n    download?: boolean;\n\n    /**\n     * Only if `options.download` is `true`. Indicates the filename under which\n     * the file will be downloaded.\n     * Default: `\"maptiler_screenshot.png\"`\n     */\n    filename?: string;\n  } = {},\n): Promise<Blob> {\n  const download = options.download ?? false;\n  const blob = await getMapScreenshotBlob(map);\n\n  if (download) {\n    const filename = options.filename ?? \"maptiler_screenshot.png\";\n\n    const link = document.createElement(\"a\");\n    link.style.display = \"none\";\n    document.body.appendChild(link);\n    link.href = URL.createObjectURL(blob);\n    link.download = filename;\n    link.click();\n\n    // Cleaning after event loop\n    setTimeout(() => {\n      document.body.removeChild(link);\n      URL.revokeObjectURL(link.href);\n    }, 0);\n  }\n\n  return blob;\n}\n\nfunction getMapScreenshotBlob(map: MapSDK): Promise<Blob> {\n  return new Promise((resolve, reject) => {\n    map.redraw();\n\n    map.once(\"idle\", () => {\n      map.getCanvas().toBlob((blob) => {\n        if (!blob) {\n          return reject(Error(\"Screenshot could not be created.\"));\n        }\n\n        resolve(blob);\n      }, \"image/png\");\n    });\n  });\n}\n","import type { DataDrivenPropertyValueSpecification, ExpressionSpecification } from \"maplibre-gl\";\nimport { generateRandomString } from \"../tools\";\nimport type { ColorRamp, RgbaColor } from \"../colorramp\";\nimport type { DataDrivenStyle, PropertyValues, ZoomNumberValues, ZoomStringValues } from \"./vectorlayerhelpers\";\n\nexport type ColorPalette = [string, string, string, string];\n\nexport const colorPalettes: Array<ColorPalette> = [\n  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n  [\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n\n  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n  [\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n\n  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n  [\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n\n  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n  [\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n\n  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n  [\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n\n  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n  [\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n\n  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n  [\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n\n  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n  [\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n\n  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n  [\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"],\n];\n\nexport function getRandomColor(): string {\n  return colorPalettes[~~(Math.random() * colorPalettes.length)][~~(Math.random() * 4)];\n}\n\nexport function generateRandomSourceName(): string {\n  return `maptiler_source_${generateRandomString()}`;\n}\n\nexport function generateRandomLayerName(): string {\n  return `maptiler_layer_${generateRandomString()}`;\n}\n\n/**\n * Linera interpolation to find a value at an arbitrary zoom level, given a list of tuple zoom-value\n */\nexport function lerpZoomNumberValues(znv: ZoomNumberValues, z: number): number {\n  // before the range\n  if (z <= znv[0].zoom) {\n    return znv[0].value;\n  }\n\n  // after the range\n  if (z >= znv[znv.length - 1].zoom) {\n    return znv[znv.length - 1].value;\n  }\n\n  // somewhere within the range\n  for (let i = 0; i < znv.length - 1; i += 1) {\n    if (z >= znv[i].zoom && z < znv[i + 1].zoom) {\n      const zoomRange = znv[i + 1].zoom - znv[i].zoom;\n      const normalizedDistanceFromLowerBound = (z - znv[i].zoom) / zoomRange;\n      return (\n        normalizedDistanceFromLowerBound * znv[i + 1].value + (1 - normalizedDistanceFromLowerBound) * znv[i].value\n      );\n    }\n  }\n\n  return 0;\n}\n\nexport function paintColorOptionsToPaintSpec(color: ZoomStringValues): DataDrivenPropertyValueSpecification<string> {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...color.flatMap((el) => [el.zoom, el.value])];\n}\n\nexport function rampedOptionsToLayerPaintSpec(ramp: ZoomNumberValues): DataDrivenPropertyValueSpecification<number> {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...ramp.flatMap((el) => [el.zoom, el.value])];\n}\n\nexport function computeRampedOutlineWidth(\n  lineWidth: number | ZoomNumberValues,\n  outlineWidth: number | ZoomNumberValues,\n): number | DataDrivenPropertyValueSpecification<number> {\n  // case 1: the line is fixed-width and the outline is fixed-width\n  if (typeof outlineWidth === \"number\" && typeof lineWidth === \"number\") {\n    return 2 * outlineWidth + lineWidth;\n  }\n\n  // case 2: the line is ramped-width, the outline is fixed-width\n  if (typeof outlineWidth === \"number\" && Array.isArray(lineWidth)) {\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...lineWidth.flatMap((el) => [el.zoom, 2 * outlineWidth + el.value])];\n  }\n\n  // case 3: the line is fixed-width, the outline is ramped-width\n  if (typeof lineWidth === \"number\" && Array.isArray(outlineWidth)) {\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...outlineWidth.flatMap((el) => [el.zoom, 2 * el.value + lineWidth])];\n  }\n\n  // case 4: the line is ramped-width, the outline is ramped-width\n  if (Array.isArray(lineWidth) && Array.isArray(outlineWidth)) {\n    // We must create an artificial set of zoom stops that includes all the zoom stops from both lists\n    // const allStops = [...lineWidth.map(el => el.zoom), ...outlineWidth.map(el => el.zoom)].sort((a: number, b: number) => a < b ? -1 : 1);\n    const allStops = Array.from(\n      new Set([...lineWidth.map((el) => el.zoom), ...outlineWidth.map((el) => el.zoom)]),\n    ).sort((a: number, b: number) => (a < b ? -1 : 1));\n\n    return [\n      \"interpolate\",\n      [\"linear\"],\n      [\"zoom\"],\n      ...allStops.flatMap((z) => [z, 2 * lerpZoomNumberValues(outlineWidth, z) + lerpZoomNumberValues(lineWidth, z)]),\n    ];\n  }\n\n  return 0;\n}\n\nexport function rampedPropertyValueWeight(\n  ramp: PropertyValues,\n  property: string,\n): DataDrivenPropertyValueSpecification<number> {\n  return [\"interpolate\", [\"linear\"], [\"get\", property], ...ramp.flatMap((el) => [el.propertyValue, el.value])];\n}\n\n/**\n * Create a dash array from a string pattern that uses underscore and whitespace characters\n */\nexport function dashArrayMaker(pattern: string): Array<number> {\n  // if the pattern starts with whitespaces, then move them towards the end\n  const startTrimmedPattern = pattern.trimStart();\n  const fixedPattern = `${startTrimmedPattern}${\" \".repeat(pattern.length - startTrimmedPattern.length)}`;\n  const patternArr = Array.from(fixedPattern);\n\n  const isOnlyDashesAndSpaces = patternArr.every((c) => c === \" \" || c === \"_\");\n  if (!isOnlyDashesAndSpaces) {\n    throw new Error(\"A dash pattern must be composed only of whitespace and underscore characters.\");\n  }\n\n  const hasBothDashesAndWhitespaces = patternArr.some((c) => c === \"_\") && patternArr.some((c) => c === \" \");\n  if (!hasBothDashesAndWhitespaces) {\n    throw new Error(\"A dash pattern must contain at least one underscore and one whitespace character\");\n  }\n\n  const dashArray = [1];\n\n  for (let i = 1; i < patternArr.length; i += 1) {\n    const previous = patternArr[i - 1];\n    const current = patternArr[i];\n\n    if (previous === current) {\n      dashArray[dashArray.length - 1] += 1;\n    } else {\n      dashArray.push(1);\n    }\n  }\n\n  return dashArray;\n}\n\nexport function colorDrivenByProperty(\n  style: DataDrivenStyle,\n  property: string,\n): DataDrivenPropertyValueSpecification<string> {\n  return [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.color])];\n}\n\nexport function radiusDrivenByProperty(\n  style: DataDrivenStyle,\n  property: string,\n  zoomCompensation = true,\n): DataDrivenPropertyValueSpecification<number> {\n  if (!zoomCompensation) {\n    return [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.pointRadius])];\n  }\n\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n\n    0,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.pointRadius * 0.025])],\n\n    2,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.pointRadius * 0.05])],\n\n    4,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.pointRadius * 0.1])],\n\n    8,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.pointRadius * 0.25])],\n\n    16,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.value, el.pointRadius])],\n  ];\n}\n\nexport function radiusDrivenByPropertyHeatmap(\n  style: PropertyValues,\n  property: string,\n  zoomCompensation = true,\n): DataDrivenPropertyValueSpecification<number> {\n  if (!zoomCompensation) {\n    return [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.propertyValue, el.value])];\n  }\n\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"zoom\"],\n\n    0,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.propertyValue, el.value * 0.025])],\n\n    2,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.propertyValue, el.value * 0.05])],\n\n    4,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.propertyValue, el.value * 0.1])],\n\n    8,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.propertyValue, el.value * 0.25])],\n\n    16,\n    [\"interpolate\", [\"linear\"], [\"get\", property], ...style.flatMap((el) => [el.propertyValue, el.value])],\n  ];\n}\n\n/**\n * Turns a ColorRamp instance into a MapLibre style for ramping the opacity, driven by a property\n */\nexport function opacityDrivenByProperty(\n  colorramp: ColorRamp,\n  property: string,\n): DataDrivenPropertyValueSpecification<number> {\n  // If all opacities are the same, just return the number without any ramping logic\n  if (colorramp.every((el) => el.color[3] === colorramp[0].color[3])) {\n    return colorramp[0].color[3] ? colorramp[0].color[3] / 255 : 1;\n  }\n\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"get\", property],\n    ...colorramp.getRawColorStops().flatMap((el) => {\n      const value = el.value;\n      const color: RgbaColor = el.color;\n      return [value, color.length === 4 ? color[3] / 255 : 1];\n    }),\n  ];\n}\n\nexport function heatmapIntensityFromColorRamp(colorRamp: ColorRamp, steps = 10): ExpressionSpecification {\n  return [\n    \"interpolate\",\n    [\"linear\"],\n    [\"heatmap-density\"],\n    ...Array.from({ length: steps + 1 }, (_, i) => {\n      const unitStep = i / steps;\n      return [unitStep, colorRamp.getColorHex(unitStep)];\n    }).flat(),\n  ];\n}\n","import type { Geometry, FeatureCollection, GeoJsonProperties } from \"geojson\";\nimport type {\n  DataDrivenPropertyValueSpecification,\n  GetResourceResponse,\n  PropertyValueSpecification,\n} from \"maplibre-gl\";\nimport type { Map as SDKMap } from \"../Map\";\nimport { config } from \"../config\";\nimport { isUUID, jsonParseNoThrow } from \"../tools\";\nimport {\n  computeRampedOutlineWidth,\n  generateRandomLayerName,\n  generateRandomSourceName,\n  getRandomColor,\n  paintColorOptionsToPaintSpec,\n  rampedOptionsToLayerPaintSpec,\n  dashArrayMaker,\n  colorDrivenByProperty,\n  radiusDrivenByProperty,\n  opacityDrivenByProperty,\n  heatmapIntensityFromColorRamp,\n  rampedPropertyValueWeight,\n  radiusDrivenByPropertyHeatmap,\n} from \"./stylehelper\";\n\nimport { gpx, gpxOrKml, kml } from \"../converters\";\nimport { ColorRampCollection, type ColorRamp } from \"../colorramp\";\n\n/**\n * Array of string values that depend on zoom level\n */\nexport type ZoomStringValues = Array<{\n  /**\n   * Zoom level\n   */\n  zoom: number;\n\n  /**\n   * Value for the given zoom level\n   */\n  value: string;\n}>;\n\n/**\n *\n * Array of number values that depend on zoom level\n */\nexport type ZoomNumberValues = Array<{\n  /**\n   * Zoom level\n   */\n  zoom: number;\n\n  /**\n   * Value for the given zoom level\n   */\n  value: number;\n}>;\n\nexport type PropertyValues = Array<{\n  /**\n   * Value of the property (input)\n   */\n  propertyValue: number;\n\n  /**\n   * Value to associate it with (output)\n   */\n  value: number;\n}>;\n\n/**\n * Describes how to render a cluster of points\n */\nexport type DataDrivenStyle = Array<{\n  /**\n   * Numerical value to observe and apply the style upon.\n   * In case of clusters, the value to observe is automatically the number of elements in a cluster.\n   * In other cases, it can be a provided value.\n   */\n  value: number;\n\n  /**\n   * Radius of the cluster circle\n   */\n  pointRadius: number;\n\n  /**\n   * Color of the cluster\n   */\n  color: string;\n}>;\n\nexport type CommonShapeLayerOptions = {\n  /**\n   * ID to give to the layer.\n   * If not provided, an auto-generated ID of the for \"maptiler-layer-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  layerId?: string;\n\n  /**\n   * ID to give to the geojson source.\n   * If not provided, an auto-generated ID of the for \"maptiler-source-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  sourceId?: string;\n\n  /**\n   * A geojson Feature collection or a URL to a geojson or the UUID of a MapTiler Cloud dataset.\n   */\n  data: FeatureCollection | string;\n\n  /**\n   * The ID of an existing layer to insert the new layer before, resulting in the new layer appearing\n   * visually beneath the existing layer. If this argument is not specified, the layer will be appended\n   * to the end of the layers array and appear visually above all other layers.\n   */\n  beforeId?: string;\n\n  /**\n   * Zoom level at which it starts to show.\n   * Default: `0`\n   */\n  minzoom?: number;\n\n  /**\n   * Zoom level after which it no longer show.\n   * Default: `22`\n   */\n  maxzoom?: number;\n\n  /**\n   * Whether or not to add an outline.\n   * Default: `false`\n   */\n  outline?: boolean;\n\n  /**\n   * Color of the outline. This is can be a constant color string or a definition based on zoom levels.\n   * Applies only if `.outline` is `true`.\n   * Default: `white`\n   */\n  outlineColor?: string | ZoomStringValues;\n\n  /**\n   * Width of the outline (relative to screen-space). This is can be a constant width or a definition based on zoom levels.\n   * Applies only if `.outline` is `true`.\n   * Default: `1`\n   */\n  outlineWidth?: number | ZoomNumberValues;\n\n  /**\n   * Opacity of the outline. This is can be a constant opacity in [0, 1] or a definition based on zoom levels\n   * Applies only if `.outline` is `true`.\n   * Default: `1`\n   */\n  outlineOpacity?: number | ZoomNumberValues;\n};\n\nexport type PolylineLayerOptions = CommonShapeLayerOptions & {\n  /**\n   * Color of the line (or polyline). This is can be a constant color string or a definition based on zoom levels.\n   * Default: a color randomly pick from a list\n   */\n  lineColor?: string | ZoomStringValues;\n\n  /**\n   * Width of the line (relative to screen-space). This is can be a constant width or a definition based on zoom levels\n   * Default: `3`\n   */\n  lineWidth?: number | ZoomNumberValues;\n\n  /**\n   * Opacity of the line. This is can be a constant opacity in [0, 1] or a definition based on zoom levels.\n   * Default: `1`\n   */\n  lineOpacity?: number | ZoomNumberValues;\n\n  /**\n   * How blury the line is, with `0` being no blur and `10` and beyond being quite blurry.\n   * Default: `0`\n   */\n  lineBlur?: number | ZoomNumberValues;\n\n  /**\n   * Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.\n   * Default: `0`\n   */\n  lineGapWidth?: number | ZoomNumberValues;\n\n  /**\n   * Sequence of line and void to create a dash pattern. The unit is the line width so that\n   * a dash array value of `[3, 1]` will create a segment worth 3 times the width of the line,\n   * followed by a spacing worth 1 time the line width, and then repeat.\n   *\n   * Alternatively, this property can be a string made of underscore and whitespace characters\n   * such as `\"___ _ \"` and internaly this will be translated into [3, 1, 1, 1]. Note that\n   * this way of describing dash arrays with a string only works for integer values.\n   *\n   * Dash arrays can contain more than 2 element to create more complex patters. For instance\n   * a dash array value of [3, 2, 1, 2] will create the following sequence:\n   * - a segment worth 3 times the width\n   * - a spacing worth 2 times the width\n   * - a segment worth 1 times the width\n   * - a spacing worth 2 times the width\n   * - repeat\n   *\n   * Default: no dash pattern\n   */\n  lineDashArray?: Array<number> | string;\n\n  /**\n   * The display of line endings for both the line and the outline (if `.outline` is `true`)\n   * - \"butt\": A cap with a squared-off end which is drawn to the exact endpoint of the line.\n   * - \"round\": A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"square\": A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * Default: \"round\"\n   */\n  lineCap?: \"butt\" | \"round\" | \"square\";\n\n  /**\n   * The display of lines when joining for both the line and the outline (if `.outline` is `true`)\n   * - \"bevel\": A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * - \"round\": A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"miter\": A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.\n   * Default: \"round\"\n   */\n  lineJoin?: \"bevel\" | \"round\" | \"miter\";\n\n  /**\n   * How blury the outline is, with `0` being no blur and `10` and beyond being quite blurry.\n   * Applies only if `.outline` is `true`.\n   * Default: `0`\n   */\n  outlineBlur?: number | ZoomNumberValues;\n};\n\nexport type PolygonLayerOptions = CommonShapeLayerOptions & {\n  /**\n   * Color of the polygon. This is can be a constant color string or a definition based on zoom levels.\n   * Default: a color randomly pick from a list\n   */\n  fillColor?: string | ZoomStringValues;\n\n  /**\n   * Opacity of the polygon. This is can be a constant opacity in [0, 1] or a definition based on zoom levels\n   * Default: `1`\n   */\n  fillOpacity?: ZoomNumberValues;\n\n  /**\n   * Position of the outline with regard to the polygon edge (when `.outline` is `true`)\n   * Default: `\"center\"`\n   */\n  outlinePosition: \"center\" | \"inside\" | \"outside\";\n\n  /**\n   * Sequence of line and void to create a dash pattern. The unit is the line width so that\n   * a dash array value of `[3, 1]` will create a segment worth 3 times the width of the line,\n   * followed by a spacing worth 1 time the line width, and then repeat.\n   *\n   * Alternatively, this property can be a string made of underscore and whitespace characters\n   * such as `\"___ _ \"` and internaly this will be translated into [3, 1, 1, 1]. Note that\n   * this way of describing dash arrays with a string only works for integer values.\n   *\n   * Dash arrays can contain more than 2 element to create more complex patters. For instance\n   * a dash array value of [3, 2, 1, 2] will create the following sequence:\n   * - a segment worth 3 times the width\n   * - a spacing worth 2 times the width\n   * - a segment worth 1 times the width\n   * - a spacing worth 2 times the width\n   * - repeat\n   *\n   * Default: no dash pattern\n   */\n  outlineDashArray?: Array<number> | string;\n\n  /**\n   * The display of line endings for both the line and the outline (if `.outline` is `true`)\n   * - \"butt\": A cap with a squared-off end which is drawn to the exact endpoint of the line.\n   * - \"round\": A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"square\": A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * Default: \"round\"\n   */\n  outlineCap?: \"butt\" | \"round\" | \"square\";\n\n  /**\n   * The display of lines when joining for both the line and the outline (if `.outline` is `true`)\n   * - \"bevel\": A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.\n   * - \"round\": A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.\n   * - \"miter\": A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.\n   * Default: \"round\"\n   */\n  outlineJoin?: \"bevel\" | \"round\" | \"miter\";\n\n  /**\n   * The pattern is an image URL to be put as a repeated background pattern of the polygon.\n   * Default: `null` (no pattern, `fillColor` will be used)\n   */\n  pattern?: string | null;\n\n  /**\n   * How blury the outline is, with `0` being no blur and `10` and beyond being quite blurry.\n   * Applies only if `.outline` is `true`.\n   * Default: `0`\n   */\n  outlineBlur?: number | ZoomNumberValues;\n};\n\nexport type PointLayerOptions = CommonShapeLayerOptions & {\n  /**\n   * Can be a unique point color as a string (CSS color such as \"#FF0000\" or \"red\").\n   * Alternatively, the color can be a ColorRamp with a range.\n   * In case of `.cluster` being `true`, the range of the ColorRamp will be addressed with the number of elements in\n   * the cluster. If `.cluster` is `false`, the color will be addressed using the value of the `.property`.\n   * If no `.property` is given but `.pointColor` is a ColorRamp, the chosen color is the one at the lower bound of the ColorRamp.\n   * Default: a color randomly pick from a list\n   */\n  pointColor?: string | ColorRamp;\n\n  /**\n   * Radius of the points. Can be a fixed size or a value dependant on the zoom.\n   * If `.pointRadius` is not provided, the radius will depend on the size of each cluster (if `.cluster` is `true`)\n   * or on the value of each point (if `.property` is provided and `.pointColor` is a ColorRamp).\n   * The radius will be between `.minPointRadius` and `.maxPointRadius`\n   */\n  pointRadius?: number | ZoomNumberValues;\n\n  /**\n   * The minimum point radius posible.\n   * Default: `10`\n   */\n  minPointRadius?: number;\n\n  /**\n   * The maximum point radius posible.\n   * Default: `40`\n   */\n  maxPointRadius?: number;\n\n  /**\n   * The point property to observe and apply the radius and color upon.\n   * This is ignored if `.cluster` is `true` as the observed value will be fiorced to being the number\n   * of elements in each cluster.\n   *\n   * Default: none\n   */\n  property?: string;\n\n  /**\n   * Opacity of the point or icon. This is can be a constant opacity in [0, 1] or a definition based on zoom levels.\n   * Alternatively, if not provided but the `.pointColor` is a ColorRamp, the opacity will be extracted from tha alpha\n   * component if present.\n   * Default: `1`\n   */\n  pointOpacity?: number | ZoomNumberValues;\n\n  /**\n   * If `true`, the points will keep their circular shape align with the wiewport.\n   * If `false`, the points will be like flatten on the map. This difference shows\n   * when the map is tilted.\n   * Default: `true`\n   */\n  alignOnViewport?: boolean;\n\n  /**\n   * Whether the points should cluster\n   */\n  cluster?: boolean;\n\n  /**\n   * Shows a label with the numerical value id `true`.\n   * If `.cluster` is `true`, the value will be the numebr of elements in the cluster.\n   *\n   *\n   * Default: `true` if `cluster` or `dataDrivenStyleProperty` are used, `false` otherwise.\n   */\n  showLabel?: boolean;\n\n  /**\n   * text color used for the number elements in each cluster.\n   * Applicable only when `cluster` is `true`.\n   * Default: `#000000` (black)\n   */\n  labelColor?: string;\n\n  /**\n   * text size used for the number elements in each cluster.\n   * Applicable only when `cluster` is `true`.\n   * Default: `12`\n   */\n  labelSize?: number;\n\n  /**\n   * Only if `.cluster` is `false`.\n   * If the radius is driven by a property, then it will also scale by zoomming if `.zoomCompensation` is `true`.\n   * If `false`, the radius will not adapt according to the zoom level.\n   * Default: `true`\n   */\n  zoomCompensation?: boolean;\n};\n\nexport type HeatmapLayerOptions = {\n  /**\n   * ID to give to the layer.\n   * If not provided, an auto-generated ID of the for \"maptiler-layer-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  layerId?: string;\n\n  /**\n   * ID to give to the geojson source.\n   * If not provided, an auto-generated ID of the for \"maptiler-source-xxxxxx\" will be auto-generated,\n   * with \"xxxxxx\" being a random string.\n   */\n  sourceId?: string;\n\n  /**\n   * A geojson Feature collection or a URL to a geojson or the UUID of a MapTiler Cloud dataset.\n   */\n  data: FeatureCollection | string;\n\n  /**\n   * The ID of an existing layer to insert the new layer before, resulting in the new layer appearing\n   * visually beneath the existing layer. If this argument is not specified, the layer will be appended\n   * to the end of the layers array and appear visually above all other layers.\n   */\n  beforeId?: string;\n\n  /**\n   * Zoom level at which it starts to show.\n   * Default: `0`\n   */\n  minzoom?: number;\n\n  /**\n   * Zoom level after which it no longer show.\n   * Default: `22`\n   */\n  maxzoom?: number;\n\n  /**\n   * The ColorRamp instance to use for visualization. The color ramp is expected to be defined in the\n   * range `[0, 1]` or else will be forced to this range.\n   * Default: `ColorRampCollection.TURBO`\n   */\n  colorRamp?: ColorRamp;\n\n  /**\n   * Use a property to apply a weight to each data point. Using a property requires also using\n   * the options `.propertyValueWeight` or otherwise will be ignored.\n   * Default: none, the points will all have a weight of `1`.\n   */\n  property?: string;\n\n  /**\n   * The weight to give to each data point. If of type `PropertyValueWeights`, then the options `.property`\n   * must also be provided. If used a number, all data points will be weighted by the same number (which is of little interest)\n   */\n  weight?: PropertyValues | number;\n\n  /**\n   * The radius (in screenspace) can be:\n   * - a fixed number that will be constant across zoom level\n   * - of type `ZoomNumberValues` to be ramped accoding to zoom level (`.zoomCompensation` will then be ignored)\n   * - of type `PropertyValues` to be driven by the value of a property.\n   *   If so, the option `.property` must be provided and will still be resized according to zoom level,\n   *   unless the option `.zoomCompensation` is set to `false`.\n   *\n   * Default:\n   */\n  radius?: number | ZoomNumberValues | PropertyValues;\n\n  /**\n   * The opacity can be a fixed value or zoom-driven.\n   * Default: fades-in 0.25z after minzoom and fade-out 0.25z before maxzoom\n   */\n  opacity?: number | ZoomNumberValues;\n\n  /**\n   * The intensity is zoom-dependent. By default, the intensity is going to be scaled by zoom to preserve\n   * a natural aspect or the data distribution.\n   */\n  intensity?: number | ZoomNumberValues;\n\n  /**\n   * If the radius is driven by a property, then it will also scale by zoomming if `.zoomCompensation` is `true`.\n   * If `false`, the radius will not adapt according to the zoom level.\n   * Default: `true`\n   */\n  zoomCompensation?: boolean;\n};\n\n/**\n * Add a polyline to the map from various sources and with builtin styling.\n * Compatible sources:\n * - gpx content as string\n * - gpx file from URL\n * - kml content from string\n * - kml from url\n * - geojson from url\n * - geojson content as string\n * - geojson content as JS object\n * - uuid of a MapTiler Cloud dataset\n *\n * The method also gives the possibility to add an outline layer (if `options.outline` is `true`)\n * and if so , the returned property `polylineOutlineLayerId` will be a string. As a result, two layers\n * would be added.\n *\n * The default styling creates a line layer of constant width of 3px, the color will be randomly picked\n * from a curated list of colors and the opacity will be 1.\n * If the outline is enabled, the outline width is of 1px at all zoom levels, the color is white and\n * the opacity is 1.\n *\n * Those style properties can be changed and ramped according to zoom level using an easier syntax.\n *\n */\nexport async function addPolyline(\n  /**\n   * Map instance to add a polyline layer to\n   */\n  map: SDKMap,\n  /**\n   * Options related to adding a polyline layer\n   */\n  options: PolylineLayerOptions,\n  /**\n   * When the polyline data is loaded from a distant source, these options are propagated to the call of `fetch`\n   */\n  fetchOptions: RequestInit = {},\n): Promise<{\n  polylineLayerId: string;\n  polylineOutlineLayerId: string;\n  polylineSourceId: string;\n}> {\n  // We need to have the sourceId of the sourceData\n  if (!options.sourceId && !options.data) {\n    throw new Error(\"Creating a polyline layer requires an existing .sourceId or a valid .data property\");\n  }\n\n  // We are going to evaluate the content of .data, if provided\n  let data = options.data;\n\n  if (typeof data === \"string\") {\n    // if options.data exists and is a uuid string, we consider that it points to a MapTiler Dataset\n    if (isUUID(data)) {\n      data = `https://api.maptiler.com/data/${options.data}/features.json?key=${config.apiKey}`;\n    }\n\n    // options.data could be a url to a .gpx file\n    else if (data.split(\".\").pop()?.toLowerCase().trim() === \"gpx\") {\n      // fetch the file\n      const res = await fetch(data, fetchOptions);\n      const gpxStr = await res.text();\n      // Convert it to geojson. Will throw is invalid GPX content\n      data = gpx(gpxStr);\n    }\n\n    // options.data could be a url to a .kml file\n    else if (data.split(\".\").pop()?.toLowerCase().trim() === \"kml\") {\n      // fetch the file\n      const res = await fetch(data, fetchOptions);\n      const kmlStr = await res.text();\n      // Convert it to geojson. Will throw is invalid GPX content\n      data = kml(kmlStr);\n    } else {\n      // From this point, we consider that the string content provided could\n      // be the string content of one of the compatible format (GeoJSON, KML, GPX)\n      const tmpData = jsonParseNoThrow<FeatureCollection<Geometry, GeoJsonProperties>>(data) ?? gpxOrKml(data);\n      if (tmpData) data = tmpData;\n    }\n\n    if (!data) {\n      throw new Error(\"Polyline data was provided as string but is incompatible with valid formats.\");\n    }\n  }\n\n  return addGeoJSONPolyline(map, {\n    ...options,\n    data,\n  });\n}\n\n/**\n * Add a polyline from a GeoJSON object\n */\nfunction addGeoJSONPolyline(\n  map: SDKMap,\n  // The data or data source is expected to contain LineStrings or MultiLineStrings\n  options: PolylineLayerOptions,\n): {\n  /**\n   * ID of the main line layer\n   */\n  polylineLayerId: string;\n\n  /**\n   * ID of the outline layer (will be `\"\"` if no outline)\n   */\n  polylineOutlineLayerId: string;\n\n  /**\n   * ID of the data source\n   */\n  polylineSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n\n  const returnedInfo = {\n    polylineLayerId: layerId,\n    polylineOutlineLayerId: \"\",\n    polylineSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: options.data,\n    });\n  }\n\n  const lineWidth = options.lineWidth ?? 3;\n  const lineColor = options.lineColor ?? getRandomColor();\n  const lineOpacity = options.lineOpacity ?? 1;\n  const lineBlur = options.lineBlur ?? 0;\n  const lineGapWidth = options.lineGapWidth ?? 0;\n  let lineDashArray = options.lineDashArray ?? null;\n  const outlineWidth = options.outlineWidth ?? 1;\n  const outlineColor = options.outlineColor ?? \"#FFFFFF\";\n  const outlineOpacity = options.outlineOpacity ?? 1;\n  const outlineBlur = options.outlineBlur ?? 0;\n\n  if (typeof lineDashArray === \"string\") {\n    lineDashArray = dashArrayMaker(lineDashArray);\n  }\n\n  // We want to create an outline for this line layer\n  if (options.outline === true) {\n    const outlineLayerId = `${layerId}_outline`;\n    returnedInfo.polylineOutlineLayerId = outlineLayerId;\n\n    map.addLayer(\n      {\n        id: outlineLayerId,\n        type: \"line\",\n        source: sourceId,\n        layout: {\n          \"line-join\": options.lineJoin ?? \"round\",\n          \"line-cap\": options.lineCap ?? \"round\",\n        },\n        minzoom: options.minzoom ?? 0,\n        maxzoom: options.maxzoom ?? 23,\n        paint: {\n          \"line-opacity\":\n            typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n          \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          \"line-width\": computeRampedOutlineWidth(lineWidth, outlineWidth),\n          \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur),\n        },\n      },\n      options.beforeId,\n    );\n  }\n\n  map.addLayer(\n    {\n      id: layerId,\n      type: \"line\",\n      source: sourceId,\n      layout: {\n        \"line-join\": options.lineJoin ?? \"round\",\n        \"line-cap\": options.lineCap ?? \"round\",\n      },\n      minzoom: options.minzoom ?? 0,\n      maxzoom: options.maxzoom ?? 23,\n      paint: {\n        \"line-opacity\": typeof lineOpacity === \"number\" ? lineOpacity : rampedOptionsToLayerPaintSpec(lineOpacity),\n        \"line-color\": typeof lineColor === \"string\" ? lineColor : paintColorOptionsToPaintSpec(lineColor),\n        \"line-width\": typeof lineWidth === \"number\" ? lineWidth : rampedOptionsToLayerPaintSpec(lineWidth),\n\n        \"line-blur\": typeof lineBlur === \"number\" ? lineBlur : rampedOptionsToLayerPaintSpec(lineBlur),\n\n        \"line-gap-width\": typeof lineGapWidth === \"number\" ? lineGapWidth : rampedOptionsToLayerPaintSpec(lineGapWidth),\n\n        // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n        // results in no showing the line while it should have the same behavior\n        // of not adding the property \"line-dasharray\" as all.\n        // As a workaround, we are inlining the addition of the prop with a conditional\n        // which is less readable.\n        ...(lineDashArray && { \"line-dasharray\": lineDashArray }),\n      },\n    },\n    options.beforeId,\n  );\n\n  return returnedInfo;\n}\n\n/**\n * Add a polygon with styling options.\n */\nexport function addPolygon(\n  map: SDKMap,\n  // this Feature collection is expected to contain on LineStrings and MultiLinestrings\n  options: PolygonLayerOptions,\n): {\n  /**\n   * ID of the fill layer\n   */\n  polygonLayerId: string;\n\n  /**\n   * ID of the outline layer (will be `\"\"` if no outline)\n   */\n  polygonOutlineLayerId: string;\n\n  /**\n   * ID of the source that contains the data\n   */\n  polygonSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n\n  const returnedInfo = {\n    polygonLayerId: layerId,\n    polygonOutlineLayerId: options.outline ? `${layerId}_outline` : \"\",\n    polygonSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    let data: string | FeatureCollection = options.data;\n\n    // If is a UUID, we extend it to be the URL to a MapTiler Cloud hosted dataset\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: data,\n    });\n  }\n\n  let outlineDashArray = options.outlineDashArray ?? null;\n  const outlineWidth = options.outlineWidth ?? 1;\n  const outlineColor = options.outlineColor ?? \"#FFFFFF\";\n  const outlineOpacity = options.outlineOpacity ?? 1;\n  const outlineBlur = options.outlineBlur ?? 0;\n  const fillColor = options.fillColor ?? getRandomColor();\n  const fillOpacity = options.fillOpacity ?? 1;\n  const outlinePosition = options.outlinePosition ?? \"center\";\n  const pattern = options.pattern ?? null;\n\n  if (typeof outlineDashArray === \"string\") {\n    outlineDashArray = dashArrayMaker(outlineDashArray);\n  }\n\n  const addLayers = (patternImageId: string | null = null) => {\n    map.addLayer(\n      {\n        id: layerId,\n        type: \"fill\",\n        source: sourceId,\n        minzoom: options.minzoom ?? 0,\n        maxzoom: options.maxzoom ?? 23,\n        paint: {\n          \"fill-color\": typeof fillColor === \"string\" ? fillColor : paintColorOptionsToPaintSpec(fillColor),\n\n          \"fill-opacity\": typeof fillOpacity === \"number\" ? fillOpacity : rampedOptionsToLayerPaintSpec(fillOpacity),\n\n          // Adding a pattern if provided\n          ...(patternImageId && { \"fill-pattern\": patternImageId }),\n        },\n      },\n      options.beforeId,\n    );\n\n    // We want to create an outline for this line layer\n    if (options.outline === true) {\n      let computedOutlineOffset: DataDrivenPropertyValueSpecification<number> | number;\n\n      if (outlinePosition === \"inside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = 0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map(({ zoom, value }) => ({\n              zoom,\n              value: 0.5 * value,\n            })),\n          );\n        }\n      } else if (outlinePosition === \"outside\") {\n        if (typeof outlineWidth === \"number\") {\n          computedOutlineOffset = -0.5 * outlineWidth;\n        } else {\n          computedOutlineOffset = rampedOptionsToLayerPaintSpec(\n            outlineWidth.map((el) => ({\n              zoom: el.zoom,\n              value: -0.5 * el.value,\n            })),\n          );\n        }\n      } else {\n        computedOutlineOffset = 0;\n      }\n\n      map.addLayer(\n        {\n          id: returnedInfo.polygonOutlineLayerId,\n          type: \"line\",\n          source: sourceId,\n          layout: {\n            \"line-join\": options.outlineJoin ?? \"round\",\n            \"line-cap\": options.outlineCap ?? \"butt\",\n          },\n          minzoom: options.minzoom ?? 0,\n          maxzoom: options.maxzoom ?? 23,\n          paint: {\n            \"line-opacity\":\n              typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n            \"line-color\": typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n            \"line-width\": typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n            \"line-blur\": typeof outlineBlur === \"number\" ? outlineBlur : rampedOptionsToLayerPaintSpec(outlineBlur),\n\n            \"line-offset\": computedOutlineOffset,\n\n            // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n            // results in no showing the line while it should have the same behavior\n            // of not adding the property \"line-dasharray\" as all.\n            // As a workaround, we are inlining the addition of the prop with a conditional\n            // which is less readable.\n            ...(outlineDashArray && {\n              \"line-dasharray\": outlineDashArray as PropertyValueSpecification<number[]>,\n            }),\n          },\n        },\n        options.beforeId,\n      );\n    }\n  };\n\n  if (pattern) {\n    if (map.hasImage(pattern)) {\n      addLayers(pattern);\n    } else {\n      map\n        .loadImage(pattern)\n        .then((value: GetResourceResponse<HTMLImageElement | ImageBitmap>) => {\n          // Add the image to the map style, using the image URL as an ID\n          map.addImage(pattern, value.data);\n          addLayers(pattern);\n        })\n        .catch((err: Error) => {\n          console.error(\"Could not load the pattern image.\", err.message);\n          return addLayers();\n        });\n    }\n  } else {\n    addLayers();\n  }\n\n  return returnedInfo;\n}\n\n/**\n * Add a point layer from a GeoJSON source (or an existing sourceId) with many styling options\n */\nexport function addPoint(\n  /**\n   * The Map instance to add a point layer to\n   */\n  map: SDKMap,\n  // The data or data source is expected to contain LineStrings or MultiLineStrings\n  options: PointLayerOptions,\n): {\n  /**\n   * ID of the unclustered point layer\n   */\n  pointLayerId: string;\n\n  /**\n   * ID of the clustered point layer (empty if `cluster` options id `false`)\n   */\n  clusterLayerId: string;\n\n  /**\n   * ID of the layer that shows the count of elements in each cluster (empty if `cluster` options id `false`)\n   */\n  labelLayerId: string;\n\n  /**\n   * ID of the data source\n   */\n  pointSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n\n  const minPointRadius = options.minPointRadius ?? 10;\n  const maxPointRadius = options.maxPointRadius ?? 50;\n  const cluster = options.cluster ?? false;\n  const nbDefaultDataDrivenStyleSteps = 20;\n  const colorramp = Array.isArray(options.pointColor)\n    ? options.pointColor\n    : ColorRampCollection.TURBO.scale(10, options.cluster ? 10000 : 1000).resample(\"ease-out-square\");\n  const colorRampBounds = colorramp.getBounds();\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n  const showLabel = options.showLabel ?? cluster;\n  const alignOnViewport = options.alignOnViewport ?? true;\n  const outline = options.outline ?? false;\n  const outlineOpacity = options.outlineOpacity ?? 1;\n  const outlineWidth = options.outlineWidth ?? 1;\n  const outlineColor = options.outlineColor ?? \"#FFFFFF\";\n  let pointOpacity: DataDrivenPropertyValueSpecification<number> | number;\n  const zoomCompensation = options.zoomCompensation ?? true;\n  const minzoom = options.minzoom ?? 0;\n  const maxzoom = options.maxzoom ?? 23;\n\n  if (typeof options.pointOpacity === \"number\") {\n    pointOpacity = options.pointOpacity;\n  } else if (Array.isArray(options.pointOpacity)) {\n    pointOpacity = rampedOptionsToLayerPaintSpec(options.pointOpacity);\n  } else if (options.cluster) {\n    pointOpacity = opacityDrivenByProperty(colorramp, \"point_count\");\n  } else if (options.property) {\n    pointOpacity = opacityDrivenByProperty(colorramp, options.property);\n  } else {\n    pointOpacity = rampedOptionsToLayerPaintSpec([\n      { zoom: minzoom, value: 0 },\n      { zoom: minzoom + 0.25, value: 1 },\n      { zoom: maxzoom - 0.25, value: 1 },\n      { zoom: maxzoom, value: 0 },\n    ]);\n  }\n\n  const returnedInfo = {\n    pointLayerId: layerId,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    let data: string | FeatureCollection = options.data;\n\n    // If is a UUID, we extend it to be the URL to a MapTiler Cloud hosted dataset\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: data,\n      cluster,\n    });\n  }\n\n  if (cluster) {\n    // If using clusters, the size and color of the circles (clusters) are driven by the\n    // numbner of elements they contain and cannot be driven by the zoom level or a property\n\n    returnedInfo.clusterLayerId = `${layerId}_cluster`;\n\n    const clusterStyle: DataDrivenStyle = Array.from({ length: nbDefaultDataDrivenStyleSteps }, (_, i) => {\n      const value =\n        colorRampBounds.min + (i * (colorRampBounds.max - colorRampBounds.min)) / (nbDefaultDataDrivenStyleSteps - 1);\n      return {\n        value,\n        pointRadius:\n          minPointRadius + (maxPointRadius - minPointRadius) * (i / (nbDefaultDataDrivenStyleSteps - 1)) ** 0.5,\n        color: colorramp.getColorHex(value),\n      };\n    });\n\n    map.addLayer(\n      {\n        id: returnedInfo.clusterLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"has\", \"point_count\"],\n        paint: {\n          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n          \"circle-color\":\n            typeof options.pointColor === \"string\"\n              ? options.pointColor\n              : colorDrivenByProperty(clusterStyle, \"point_count\"),\n\n          \"circle-radius\":\n            typeof options.pointRadius === \"number\"\n              ? options.pointRadius\n              : Array.isArray(options.pointRadius)\n                ? rampedOptionsToLayerPaintSpec(options.pointRadius)\n                : radiusDrivenByProperty(clusterStyle, \"point_count\", false),\n\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\", // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-opacity\": pointOpacity,\n          ...(outline && {\n            \"circle-stroke-opacity\":\n              typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n\n            \"circle-stroke-width\":\n              typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n\n            \"circle-stroke-color\":\n              typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          }),\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n\n    // Adding the layer of unclustered point (visible only when ungrouped)\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        filter: [\"!\", [\"has\", \"point_count\"]],\n        paint: {\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\", // scale with camera distance regardless of viewport/biewport alignement\n          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n          \"circle-color\":\n            typeof options.pointColor === \"string\"\n              ? options.pointColor\n              : colorramp.getColorHex(colorramp.getBounds().min),\n          \"circle-radius\":\n            typeof options.pointRadius === \"number\"\n              ? options.pointRadius\n              : Array.isArray(options.pointRadius)\n                ? rampedOptionsToLayerPaintSpec(options.pointRadius)\n                : clusterStyle[0].pointRadius * 0.75,\n          \"circle-opacity\": pointOpacity,\n          ...(outline && {\n            \"circle-stroke-opacity\":\n              typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n\n            \"circle-stroke-width\":\n              typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n\n            \"circle-stroke-color\":\n              typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          }),\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n  }\n\n  // Not displaying clusters\n  else {\n    let pointColor: DataDrivenPropertyValueSpecification<string> =\n      typeof options.pointColor === \"string\"\n        ? options.pointColor\n        : Array.isArray(options.pointColor)\n          ? options.pointColor.getColorHex(options.pointColor.getBounds().min) // if color ramp is given, we choose the first color of it, even if the property may not be provided\n          : getRandomColor();\n\n    let pointRadius: DataDrivenPropertyValueSpecification<number> =\n      typeof options.pointRadius === \"number\"\n        ? zoomCompensation\n          ? rampedOptionsToLayerPaintSpec([\n              { zoom: 0, value: options.pointRadius * 0.025 },\n              { zoom: 2, value: options.pointRadius * 0.05 },\n              { zoom: 4, value: options.pointRadius * 0.1 },\n              { zoom: 8, value: options.pointRadius * 0.25 },\n              { zoom: 16, value: options.pointRadius * 1 },\n            ])\n          : options.pointRadius\n        : Array.isArray(options.pointRadius)\n          ? rampedOptionsToLayerPaintSpec(options.pointRadius)\n          : zoomCompensation\n            ? rampedOptionsToLayerPaintSpec([\n                { zoom: 0, value: minPointRadius * 0.05 },\n                { zoom: 2, value: minPointRadius * 0.1 },\n                { zoom: 4, value: minPointRadius * 0.2 },\n                { zoom: 8, value: minPointRadius * 0.5 },\n                { zoom: 16, value: minPointRadius * 1 },\n              ])\n            : minPointRadius;\n\n    // If the styling depends on a property, then we build a custom style\n    if (options.property && Array.isArray(options.pointColor)) {\n      const dataDrivenStyle: DataDrivenStyle = Array.from({ length: nbDefaultDataDrivenStyleSteps }, (_, i) => {\n        const value =\n          colorRampBounds.min + (i * (colorRampBounds.max - colorRampBounds.min)) / (nbDefaultDataDrivenStyleSteps - 1);\n        return {\n          value,\n          pointRadius:\n            typeof options.pointRadius === \"number\"\n              ? options.pointRadius\n              : minPointRadius + (maxPointRadius - minPointRadius) * (i / (nbDefaultDataDrivenStyleSteps - 1)) ** 0.5,\n          color: typeof options.pointColor === \"string\" ? options.pointColor : colorramp.getColorHex(value),\n        };\n      });\n      pointColor = colorDrivenByProperty(dataDrivenStyle, options.property);\n      pointRadius = radiusDrivenByProperty(dataDrivenStyle, options.property, zoomCompensation);\n    }\n\n    // Adding the layer of unclustered point\n    map.addLayer(\n      {\n        id: returnedInfo.pointLayerId,\n        type: \"circle\",\n        source: sourceId,\n        layout: {\n          // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n          \"circle-sort-key\": options.property ? [\"/\", 1, [\"get\", options.property]] : 0,\n        },\n        paint: {\n          \"circle-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"circle-pitch-scale\": \"map\", // scale with camera distance regardless of viewport/biewport alignement\n          \"circle-color\": pointColor,\n          \"circle-opacity\": pointOpacity,\n          \"circle-radius\": pointRadius,\n\n          ...(outline && {\n            \"circle-stroke-opacity\":\n              typeof outlineOpacity === \"number\" ? outlineOpacity : rampedOptionsToLayerPaintSpec(outlineOpacity),\n\n            \"circle-stroke-width\":\n              typeof outlineWidth === \"number\" ? outlineWidth : rampedOptionsToLayerPaintSpec(outlineWidth),\n\n            \"circle-stroke-color\":\n              typeof outlineColor === \"string\" ? outlineColor : paintColorOptionsToPaintSpec(outlineColor),\n          }),\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n  }\n\n  if (showLabel !== false && (options.cluster || options.property)) {\n    returnedInfo.labelLayerId = `${layerId}_label`;\n    const labelColor = options.labelColor ?? \"#fff\";\n    const labelSize = options.labelSize ?? 12;\n\n    // With clusters, a layer with clouster count is also added\n    map.addLayer(\n      {\n        id: returnedInfo.labelLayerId,\n        type: \"symbol\",\n        source: sourceId,\n        filter: [\"has\", options.cluster ? \"point_count\" : (options.property as string)],\n        layout: {\n          \"text-field\": options.cluster ? \"{point_count_abbreviated}\" : `{${options.property as string}}`,\n          \"text-font\": [\"Noto Sans Regular\"],\n          \"text-size\": labelSize,\n          \"text-pitch-alignment\": alignOnViewport ? \"viewport\" : \"map\",\n          \"symbol-sort-key\": [\"/\", 1, [\"get\", options.cluster ? \"point_count\" : (options.property as string)]], // so that the largest value goes on top\n        },\n        paint: {\n          \"text-color\": labelColor,\n          \"text-opacity\": pointOpacity,\n        },\n        minzoom,\n        maxzoom,\n      },\n      options.beforeId,\n    );\n  }\n  return returnedInfo;\n}\n\n/**\n * Add a polyline witgh optional outline from a GeoJSON object\n */\nexport function addHeatmap(\n  /**\n   * Map instance to add a heatmap layer to\n   */\n  map: SDKMap,\n  // The data or data source is expected to contain LineStrings or MultiLineStrings\n  options: HeatmapLayerOptions,\n): {\n  /**\n   * ID of the heatmap layer\n   */\n  heatmapLayerId: string;\n\n  /**\n   * ID of the data source\n   */\n  heatmapSourceId: string;\n} {\n  if (options.layerId && map.getLayer(options.layerId)) {\n    throw new Error(`A layer already exists with the layer id: ${options.layerId}`);\n  }\n\n  const sourceId = options.sourceId ?? generateRandomSourceName();\n  const layerId = options.layerId ?? generateRandomLayerName();\n  const minzoom = options.minzoom ?? 0;\n  const maxzoom = options.maxzoom ?? 23;\n  const zoomCompensation = options.zoomCompensation ?? true;\n\n  const opacity = options.opacity ?? [\n    { zoom: minzoom, value: 0 },\n    { zoom: minzoom + 0.25, value: 1 },\n    { zoom: maxzoom - 0.25, value: 1 },\n    { zoom: maxzoom, value: 0 },\n  ];\n\n  // const colorRamp = \"colorRamp\" in options\n  let colorRamp = Array.isArray(options.colorRamp) ? options.colorRamp : ColorRampCollection.TURBO.transparentStart();\n\n  // making sure the color ramp has [0, 1] bounds\n  const crBounds = colorRamp.getBounds();\n  if (crBounds.min !== 0 || crBounds.max !== 1) {\n    colorRamp = colorRamp.scale(0, 1);\n  }\n\n  // making sure the color ramp has is transparent in 0\n  if (!colorRamp.hasTransparentStart()) {\n    colorRamp = colorRamp.transparentStart();\n  }\n\n  const intensity = options.intensity ?? [\n    { zoom: 0, value: 0.01 },\n    { zoom: 4, value: 0.2 },\n    { zoom: 16, value: 1 },\n  ];\n\n  const property = options.property ?? null;\n  const propertyValueWeight = options.weight ?? 1;\n\n  let heatmapWeight: DataDrivenPropertyValueSpecification<number> = 1; // = typeof propertyValueWeights === \"number\" ? propertyValueWeights : 1;\n\n  if (property) {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n\n      // In case this numerical weight was provided by the user and not be the default value:\n      if (typeof options.weight === \"number\") {\n        console.warn(\n          \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\",\n        );\n      }\n    } else if (Array.isArray(propertyValueWeight)) {\n      heatmapWeight = rampedPropertyValueWeight(propertyValueWeight, property);\n    } else {\n      console.warn(\n        \"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\",\n      );\n    }\n  } else {\n    if (typeof propertyValueWeight === \"number\") {\n      heatmapWeight = propertyValueWeight;\n    } else if (Array.isArray(propertyValueWeight)) {\n      console.warn(\"The options `.propertyValueWeights` can only be used when `.property` is provided.\");\n    }\n  }\n\n  const defaultRadiusZoomRamping = [\n    { zoom: 0, value: 50 * 0.025 },\n    { zoom: 2, value: 50 * 0.05 },\n    { zoom: 4, value: 50 * 0.1 },\n    { zoom: 8, value: 50 * 0.25 },\n    { zoom: 16, value: 50 },\n  ];\n\n  const radius = options.radius ?? (zoomCompensation ? defaultRadiusZoomRamping : 10);\n\n  let radiusHeatmap: DataDrivenPropertyValueSpecification<number> = 1;\n\n  if (typeof radius === \"number\") {\n    radiusHeatmap = radius;\n  }\n\n  // Radius is provided as a zoom-ramping array\n  else if (Array.isArray(radius) && \"zoom\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(radius as ZoomNumberValues);\n  }\n\n  // Radius is provided as data driven\n  else if (property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = radiusDrivenByPropertyHeatmap(radius as unknown as PropertyValues, property, zoomCompensation);\n  } else if (!property && Array.isArray(radius) && \"propertyValue\" in radius[0]) {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(defaultRadiusZoomRamping as ZoomNumberValues);\n    console.warn(\"The option `.radius` can only be property-driven if the option `.property` is provided.\");\n  } else {\n    radiusHeatmap = rampedOptionsToLayerPaintSpec(defaultRadiusZoomRamping as ZoomNumberValues);\n  }\n\n  const returnedInfo = {\n    heatmapLayerId: layerId,\n    heatmapSourceId: sourceId,\n  };\n\n  // A new source is added if the map does not have this sourceId and the data is provided\n  if (options.data && !map.getSource(sourceId)) {\n    let data: string | FeatureCollection = options.data;\n\n    // If is a UUID, we extend it to be the URL to a MapTiler Cloud hosted dataset\n    if (typeof data === \"string\" && isUUID(data)) {\n      data = `https://api.maptiler.com/data/${data}/features.json?key=${config.apiKey}`;\n    }\n\n    // Adding the source\n    map.addSource(sourceId, {\n      type: \"geojson\",\n      data: data,\n    });\n  }\n\n  map.addLayer(\n    {\n      id: layerId,\n      type: \"heatmap\",\n      source: sourceId,\n      minzoom,\n      maxzoom,\n      paint: {\n        \"heatmap-weight\": heatmapWeight,\n\n        \"heatmap-intensity\":\n          typeof intensity === \"number\"\n            ? intensity\n            : (rampedOptionsToLayerPaintSpec(intensity) as PropertyValueSpecification<number>),\n\n        \"heatmap-color\": heatmapIntensityFromColorRamp(colorRamp),\n\n        \"heatmap-radius\": radiusHeatmap,\n\n        \"heatmap-opacity\":\n          typeof opacity === \"number\"\n            ? opacity\n            : (rampedOptionsToLayerPaintSpec(opacity) as PropertyValueSpecification<number>),\n      },\n    },\n    options.beforeId,\n  );\n\n  return returnedInfo;\n}\n","import { takeScreenshot } from \"./screenshot\";\nimport { addPolyline, addPolygon, addPoint, addHeatmap } from \"./vectorlayerhelpers\";\n\nexport type {\n  ZoomStringValues,\n  ZoomNumberValues,\n  PropertyValues,\n  CommonShapeLayerOptions,\n  PolylineLayerOptions,\n  PolygonLayerOptions,\n  PointLayerOptions,\n  HeatmapLayerOptions,\n} from \"./vectorlayerhelpers\";\n\n/**\n * Helpers are a set of functions to facilitate the creation of sources and layers\n */\nexport const helpers = {\n  addPolyline,\n  addPolygon,\n  addPoint,\n  addHeatmap,\n  takeScreenshot,\n};\n","import packagejson from \"../package.json\";\nimport { enableRTL } from \"./tools\";\n\nimport maplibregl from \"maplibre-gl\";\n\n// Types from MapLibre are not re-exported one by one\nexport type * from \"maplibre-gl\";\n\n// Enabling the right-to-left text compatibility plugin early to avoid blinking\nenableRTL();\n\n/**\n * Get the version of MapTiler SDK\n */\nexport function getVersion(): string {\n  return packagejson.version;\n}\n\nconst MapMLGL = maplibregl.Map;\nconst MarkerMLGL = maplibregl.Marker;\nconst PopupMLGL = maplibregl.Popup;\nconst StyleMLGL = maplibregl.Style;\nconst CanvasSourceMLGL = maplibregl.CanvasSource;\nconst GeoJSONSourceMLGL = maplibregl.GeoJSONSource;\nconst ImageSourceMLGL = maplibregl.ImageSource;\nconst RasterTileSourceMLGL = maplibregl.RasterTileSource;\nconst RasterDEMTileSourceMLGL = maplibregl.RasterDEMTileSource;\nconst VectorTileSourceMLGL = maplibregl.VectorTileSource;\nconst VideoSourceMLGL = maplibregl.VideoSource;\nconst NavigationControMLGL = maplibregl.NavigationControl;\nconst GeolocateControlMLGL = maplibregl.GeolocateControl;\nconst AttributionControlMLGL = maplibregl.AttributionControl;\nconst LogoControlMLGL = maplibregl.LogoControl;\nconst ScaleControlMLGL = maplibregl.ScaleControl;\nconst FullscreenControlMLGL = maplibregl.FullscreenControl;\nconst TerrainControMLGL = maplibregl.TerrainControl;\nconst BoxZoomHandlerMLGL = maplibregl.BoxZoomHandler;\nconst ScrollZoomHandlerMLGL = maplibregl.ScrollZoomHandler;\nconst CooperativeGesturesHandlerMLGL = maplibregl.CooperativeGesturesHandler;\nconst KeyboardHandlerMLGL = maplibregl.KeyboardHandler;\nconst TwoFingersTouchPitchHandlerMLGL = maplibregl.TwoFingersTouchPitchHandler;\nconst MapWheelEventMLGL = maplibregl.MapWheelEvent;\nconst MapTouchEventMLGL = maplibregl.MapTouchEvent;\nconst MapMouseEventMLGL = maplibregl.MapMouseEvent;\nconst configMLGL = maplibregl.config;\nconst getMapLibreVersion = maplibregl.getVersion;\n\nconst {\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  Hash,\n  Point,\n  EdgeInsets,\n  DragRotateHandler,\n  DragPanHandler,\n  TwoFingersTouchZoomRotateHandler,\n  DoubleClickZoomHandler,\n  TwoFingersTouchZoomHandler,\n  TwoFingersTouchRotateHandler,\n  getWorkerCount,\n  setWorkerCount,\n  getMaxParallelImageRequests,\n  setMaxParallelImageRequests,\n  getWorkerUrl,\n  setWorkerUrl,\n  addSourceType,\n  importScriptInWorkers,\n  addProtocol,\n  removeProtocol,\n} = maplibregl;\n\nexport {\n  setRTLTextPlugin,\n  getRTLTextPluginStatus,\n  LngLat,\n  LngLatBounds,\n  // biome-ignore lint/style/useExportType: Biome thinks those are only type while they are actually full fledge classes\n  MercatorCoordinate,\n  Evented,\n  AJAXError,\n  prewarm,\n  clearPrewarmedResources,\n  Hash,\n  Point,\n  EdgeInsets,\n  DragRotateHandler,\n  DragPanHandler,\n  TwoFingersTouchZoomRotateHandler,\n  DoubleClickZoomHandler,\n  TwoFingersTouchZoomHandler,\n  TwoFingersTouchRotateHandler,\n  getWorkerCount,\n  setWorkerCount,\n  getMaxParallelImageRequests,\n  setMaxParallelImageRequests,\n  getWorkerUrl,\n  setWorkerUrl,\n  addSourceType,\n  importScriptInWorkers,\n  addProtocol,\n  removeProtocol,\n  // Below: Exported from MapLibre but as a different name\n  // in case dev wants to use the non-overloaded versions\n  getMapLibreVersion,\n  MapMLGL,\n  MarkerMLGL,\n  PopupMLGL,\n  StyleMLGL,\n  CanvasSourceMLGL,\n  GeoJSONSourceMLGL,\n  ImageSourceMLGL,\n  RasterTileSourceMLGL,\n  RasterDEMTileSourceMLGL,\n  VectorTileSourceMLGL,\n  VideoSourceMLGL,\n  NavigationControMLGL,\n  GeolocateControlMLGL,\n  AttributionControlMLGL,\n  LogoControlMLGL,\n  ScaleControlMLGL,\n  FullscreenControlMLGL,\n  TerrainControMLGL,\n  BoxZoomHandlerMLGL,\n  ScrollZoomHandlerMLGL,\n  CooperativeGesturesHandlerMLGL,\n  KeyboardHandlerMLGL,\n  TwoFingersTouchPitchHandlerMLGL,\n  MapWheelEventMLGL,\n  MapTouchEventMLGL,\n  MapMouseEventMLGL,\n  configMLGL,\n};\n\n// Attaching the types to the\nexport type LngLat = InstanceType<typeof LngLat>;\nexport type LngLatBounds = InstanceType<typeof LngLatBounds>;\nexport type MercatorCoordinate = InstanceType<typeof MercatorCoordinate>;\nexport type Evented = InstanceType<typeof Evented>;\nexport type AJAXError = InstanceType<typeof AJAXError>;\nexport type Hash = InstanceType<typeof Hash>;\nexport type Point = InstanceType<typeof Point>;\nexport type EdgeInsets = InstanceType<typeof EdgeInsets>;\nexport type DragRotateHandler = InstanceType<typeof DragRotateHandler>;\nexport type DragPanHandler = InstanceType<typeof DragPanHandler>;\nexport type TwoFingersTouchZoomRotateHandler = InstanceType<typeof TwoFingersTouchZoomRotateHandler>;\nexport type DoubleClickZoomHandler = InstanceType<typeof DoubleClickZoomHandler>;\nexport type TwoFingersTouchZoomHandler = InstanceType<typeof TwoFingersTouchZoomHandler>;\nexport type TwoFingersTouchRotateHandler = InstanceType<typeof TwoFingersTouchRotateHandler>;\n\n// The following items are only MapLibre adapted to MapTiler SDK Map class\nexport { Marker } from \"./MLAdapters/Marker\";\nexport { Popup } from \"./MLAdapters/Popup\";\nexport { Style } from \"./MLAdapters/Style\";\nexport { CanvasSource } from \"./MLAdapters/CanvasSource\";\nexport { GeoJSONSource } from \"./MLAdapters/GeoJSONSource\";\nexport { ImageSource } from \"./MLAdapters/ImageSource\";\nexport { RasterTileSource } from \"./MLAdapters/RasterTileSource\";\nexport { RasterDEMTileSource } from \"./MLAdapters/RasterDEMTileSource\";\nexport { VectorTileSource } from \"./MLAdapters/VectorTileSource\";\nexport { VideoSource } from \"./MLAdapters/VideoSource\";\nexport { NavigationControl } from \"./MLAdapters/NavigationControl\";\nexport { GeolocateControl } from \"./MLAdapters/GeolocateControl\";\nexport { AttributionControl } from \"./MLAdapters/AttributionControl\";\nexport { LogoControl } from \"./MLAdapters/LogoControl\";\nexport { ScaleControl } from \"./MLAdapters/ScaleControl\";\nexport { FullscreenControl } from \"./MLAdapters/FullscreenControl\";\nexport { TerrainControl } from \"./MLAdapters/TerrainControl\";\nexport { BoxZoomHandler } from \"./MLAdapters/BoxZoomHandler\";\nexport { ScrollZoomHandler } from \"./MLAdapters/ScrollZoomHandler\";\nexport { CooperativeGesturesHandler } from \"./MLAdapters/CooperativeGesturesHandler\";\nexport { KeyboardHandler } from \"./MLAdapters/KeyboardHandler\";\nexport { TwoFingersTouchPitchHandler } from \"./MLAdapters/TwoFingersTouchPitchHandler\";\nexport { MapWheelEvent } from \"./MLAdapters/MapWheelEvent\";\nexport { MapTouchEvent } from \"./MLAdapters/MapTouchEvent\";\nexport { MapMouseEvent } from \"./MLAdapters/MapMouseEvent\";\n\n// SDK specific\nexport {\n  Map,\n  GeolocationType,\n  type MapOptions,\n  type LoadWithTerrainEvent,\n} from \"./Map\";\nexport * from \"./MaptilerGeolocateControl\";\nexport * from \"./MaptilerLogoControl\";\nexport * from \"./MaptilerTerrainControl\";\nexport * from \"./MaptilerNavigationControl\";\nexport {\n  type AutomaticStaticMapOptions,\n  type BoundedStaticMapOptions,\n  type BufferToPixelDataFunction,\n  type ByIdGeocodingOptions,\n  type CenteredStaticMapOptions,\n  type CommonForwardAndReverseGeocodingOptions,\n  type CoordinateExport,\n  type CoordinateGrid,\n  type CoordinateId,\n  type CoordinateSearch,\n  type CoordinateSearchResult,\n  type CoordinateTransformResult,\n  type CoordinateTransformation,\n  type Coordinates,\n  type CoordinatesSearchOptions,\n  type CoordinatesTransformOptions,\n  type DefaultTransformation,\n  type ElevationAtOptions,\n  type ElevationBatchOptions,\n  type FeatureHierarchy,\n  type FetchFunction,\n  type GeocodingFeature,\n  type GeocodingOptions,\n  type GeocodingSearchResult,\n  type GeolocationInfoOptions,\n  type GeolocationResult,\n  type GetDataOptions,\n  type LanguageGeocodingOptions,\n  MapStyle,\n  type MapStylePreset,\n  type MapStyleType,\n  MapStyleVariant,\n  type PixelData,\n  ReferenceMapStyle,\n  type ReverseGeocodingOptions,\n  ServiceError,\n  type StaticMapBaseOptions,\n  type StaticMapMarker,\n  type TileJSON,\n  type XYZ,\n  bufferToPixelDataBrowser,\n  circumferenceAtLatitude,\n  coordinates,\n  data,\n  elevation,\n  expandMapStyle,\n  geocoding,\n  geolocation,\n  getBufferToPixelDataParser,\n  getTileCache,\n  mapStylePresetList,\n  math,\n  misc,\n  staticMaps,\n  styleToStyle,\n  type LanguageInfo,\n  areSameLanguages,\n  toLanguageInfo,\n  isLanguageInfo,\n  getAutoLanguage,\n  getLanguageInfoFromFlag,\n  getLanguageInfoFromCode,\n  getLanguageInfoFromKey,\n} from \"@maptiler/client\";\n\nexport { config, SdkConfig } from \"./config\";\nexport * from \"./language\";\nexport { type Unit } from \"./unit\";\nexport * from \"./Minimap\";\nexport * from \"./converters\";\nexport * from \"./colorramp\";\nexport * from \"./helpers\";\n"],"names":["Language","LanguageFromClient","getBrowserLanguage","code","langInfo","getLanguageInfoFromCode","l","li","defaults","MAPTILER_SESSION_ID","uuidv4","SdkConfig","EventEmitter","__publicField","u","k","clientConfig","f","config","addProtocol","maplibregl","LOCAL_CACHE_PROTOCOL_SOURCE","LOCAL_CACHE_PROTOCOL_DATA","LOCAL_CACHE_NAME","CACHE_LIMIT_ITEMS","CACHE_LIMIT_CHECK_INTERVAL","CACHE_API_AVAILABLE","localCacheTransformRequest","reqUrl","resourceType","cacheInstance","getCache","cachePutCounter","limitCache","cache","keys","toPurge","key","registerLocalCacheProtocol","params","abortController","requestInit","response","json","url","cacheableUrl","cacheKey","fetchableUrl","fetchUrl","respond","cacheMatch","enableRTL","status","bindAll","fns","context","fn","DOMcreate","tagName","className","container","el","DOMremove","node","maptilerCloudTransformRequest","combineTransformRequest","userDefinedRTF","rp","rp2","generateRandomString","isUUID","s","jsonParseNoThrow","doc","getWebGLSupportError","displayNoWebGlWarning","webglError","actualContainer","errorMessageDiv","Marker$1","map","Popup","Style","options","CanvasSource","GeoJSONSource","ImageSource","RasterTileSource","RasterDEMTileSource","VectorTileSource","VideoSource","NavigationControl","GeolocateControl","AttributionControl","LogoControl","ScaleControl","FullscreenControl","TerrainControl","BoxZoomHandler","ScrollZoomHandler","triggerRenderFrame","CooperativeGesturesHandler","KeyboardHandler","TwoFingersTouchPitchHandler","MapWheelEvent","type","originalEvent","MapTouchEvent","MapMouseEvent","data","MaptilerLogoControl","anchor","styleToStyle","style","expandMapStyle","MapStyleVariant","ReferenceMapStyle","MapStyle","mapStylePresetList","MaptilerTerrainControl","MaptilerNavigationControl","rotate","e","button","Marker","LngLat","LngLatBounds","MaptilerGeolocateControl","position","center","radius","currentMapZoom","_b","_a","hasFittingBeenDisrupted","flagFittingDisruption","supported","title","event","fromResize","movingDistance","lastKnownLocation","projectedLocation","b","metersPerPixel","circleDiameter","Minimap","mapOptions","__privateAdd","_Minimap_instances","_options","_parentMap","_container","_parentRect","_differentStyle","_desync","__privateSet","__privateGet","__privateMethod","setParentBounds_fn","layer","beforeId","id","layerId","minzoom","maxzoom","filter","name","value","glyphsUrl","parentMap","SDKMap","addParentRect_fn","syncMaps_fn","rect","devicePixelRatio","canvas","width","height","unproject","northWest","northEast","southWest","southEast","pitchAdjust","parentCallback","sync","minimapCallback","on","off","which","from","to","zoom","bearing","pitch","GeolocationType","Map","hashPreConstructor","attributionControlOptions","ipLocatedCameraHash","tileJsonContent","possibleSources","sourceName","styleUrl","logoURL","scaleControl","unit","loadEventTriggered","terrainEventTriggered","terrainEventData","minimap","language","apiKey","maptilerLogo","antialias","refreshExpiredTiles","maxBounds","scrollZoom","minZoom","maxZoom","boxZoom","locale","fadeDuration","crossSourceCollisions","clickTolerance","bounds","fitBoundsOptions","pixelRatio","validateStyle","terrainCallback","evt","resolve","getLanguageInfoFromFlag","lang","styleLanguage","toLanguageInfo","languageNonStyle","langStr","replacer","layers","genericLayer","source","layout","textFieldLayoutProp","exaggeration","durationMs","startTime","currentExaggeration","deltaExaggeration","updateExaggeration","positionInLoop","exaggerationFactor","newExaggeration","dataEventTerrainGrow","addTerrain","animationLoopDuration","animate","cb","ipGeolocateResult","geolocation","hashBin","Base64","transformRequest","str2xml","str","hasChildNodeWithName","nodeName","childNode","currentNodeName","xml2str","gpx","actualDoc","tracks","get","routes","waypoints","gj","track","feature","getTrack","route","getRoute","waypoint","getPoint","kml","xml2string","styleIndex","styleByHash","styleMapIndex","placemarks","styles","styleMaps","hash","okhash","attr","styleMap","pairs","pairsMap","pair","nodeVal","get1","placemark","getPlacemark","kmlColor","v","color","opacity","validV","gxCoord","numarray","gxCoords","root","elems","coords","times","elem","timeElems","timeElem","getGeometry","geotypes","geomNode","geomNodes","i","j","geoms","coordTimes","coord1","coord","rings","geomsAndTimes","properties","address","description","timeSpan","timeStamp","extendedData","visibility","lineStyle","polyStyle","iconStyle","icon","href","begin","end","linestyles","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","getPoints","pointname","pts","line","heartRates","ptsLength","cPair","coordPair","segments","getProperties","getLineStyle","getMulti","extensions","prop","links","link","x","h","y","attrf","n","norm","ys","o","out","ll","ele","heartRate","time","gpxOrKml","componentToHex","c","hex","rgbToHex","rgb","ColorRamp","cr","cs","stops","colorRamp","min","max","a","clone","currentMin","currentSpan","newSpan","newValue","pos","colorBefore","valueBefore","valueAfter","colorAfter","beforeRatio","chan","ctx","imageData","imageDataArray","size","startValue","valueStep","method","samples","inputBounds","inputNormalized","step","_","ColorRampCollection","takeScreenshot","download","blob","getMapScreenshotBlob","filename","reject","colorPalettes","getRandomColor","generateRandomSourceName","generateRandomLayerName","lerpZoomNumberValues","znv","z","zoomRange","normalizedDistanceFromLowerBound","paintColorOptionsToPaintSpec","rampedOptionsToLayerPaintSpec","ramp","computeRampedOutlineWidth","lineWidth","outlineWidth","allStops","rampedPropertyValueWeight","property","dashArrayMaker","pattern","startTrimmedPattern","fixedPattern","patternArr","dashArray","previous","current","colorDrivenByProperty","radiusDrivenByProperty","zoomCompensation","radiusDrivenByPropertyHeatmap","opacityDrivenByProperty","colorramp","heatmapIntensityFromColorRamp","steps","unitStep","addPolyline","fetchOptions","gpxStr","kmlStr","tmpData","addGeoJSONPolyline","sourceId","returnedInfo","lineColor","lineOpacity","lineBlur","lineGapWidth","lineDashArray","outlineColor","outlineOpacity","outlineBlur","outlineLayerId","addPolygon","outlineDashArray","fillColor","fillOpacity","outlinePosition","addLayers","patternImageId","computedOutlineOffset","err","addPoint","minPointRadius","maxPointRadius","cluster","nbDefaultDataDrivenStyleSteps","colorRampBounds","showLabel","alignOnViewport","pointOpacity","clusterStyle","pointColor","pointRadius","dataDrivenStyle","labelColor","labelSize","addHeatmap","crBounds","intensity","propertyValueWeight","heatmapWeight","defaultRadiusZoomRamping","radiusHeatmap","helpers","getVersion","packagejson","MapMLGL","MarkerMLGL","PopupMLGL","StyleMLGL","CanvasSourceMLGL","GeoJSONSourceMLGL","ImageSourceMLGL","RasterTileSourceMLGL","RasterDEMTileSourceMLGL","VectorTileSourceMLGL","VideoSourceMLGL","NavigationControMLGL","GeolocateControlMLGL","AttributionControlMLGL","LogoControlMLGL","ScaleControlMLGL","FullscreenControlMLGL","TerrainControMLGL","BoxZoomHandlerMLGL","ScrollZoomHandlerMLGL","CooperativeGesturesHandlerMLGL","KeyboardHandlerMLGL","TwoFingersTouchPitchHandlerMLGL","MapWheelEventMLGL","MapTouchEventMLGL","MapMouseEventMLGL","configMLGL","getMapLibreVersion","setRTLTextPlugin","getRTLTextPluginStatus","MercatorCoordinate","Evented","AJAXError","prewarm","clearPrewarmedResources","Hash","Point","EdgeInsets","DragRotateHandler","DragPanHandler","TwoFingersTouchZoomRotateHandler","DoubleClickZoomHandler","TwoFingersTouchZoomHandler","TwoFingersTouchRotateHandler","getWorkerCount","setWorkerCount","getMaxParallelImageRequests","setMaxParallelImageRequests","getWorkerUrl","setWorkerUrl","addSourceType","importScriptInWorkers","removeProtocol"],"mappings":"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"}